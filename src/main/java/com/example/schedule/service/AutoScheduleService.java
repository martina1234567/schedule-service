package com.example.schedule.service;

import com.example.schedule.entity.Employee;
import com.example.schedule.entity.Event;
import com.example.schedule.repository.EmployeeRepository;
import com.example.schedule.repository.EventRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * –°–ï–†–í–ò–° –ó–ê –ê–í–¢–û–ú–ê–¢–ò–ß–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù–ï –ù–ê –ú–ï–°–ï–ß–ï–ù –ì–†–ê–§–ò–ö
 * –¢–æ–∑–∏ —Å–µ—Ä–≤–∏—Å —Å—ä–¥—ä—Ä–∂–∞ —Ü–µ–ª–∏—è –∞–ª–≥–æ—Ä–∏—Ç—ä–º –∑–∞ —Å—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –æ–ø—Ç–∏–º–∞–ª–µ–Ω —Ä–∞–±–æ—Ç–µ–Ω –≥—Ä–∞—Ñ–∏–∫
 * —Å—ä–æ–±—Ä–∞–∑–µ–Ω —Å –≤—Å–∏—á–∫–∏ –∏–∑–∏—Å–∫–≤–∞–Ω–∏—è –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
 */
@Service
public class AutoScheduleService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private EventRepository eventRepository;

    @Autowired
    private ValidationService validationService;

    // ========================================
    // –ö–û–ù–°–¢–ê–ù–¢–ò –ó–ê –†–ê–ë–û–¢–ù–ò–¢–ï –°–ú–ï–ù–ò
    // ========================================

    // –ü—ä—Ä–≤–∞ —Å–º—è–Ω–∞: 06:00 - 14:30 (8.5 —á–∞—Å–∞ —Å 30 –º–∏–Ω –ø–æ—á–∏–≤–∫–∞)
    private static final LocalTime FIRST_SHIFT_START = LocalTime.of(6, 0);
    private static final LocalTime FIRST_SHIFT_END = LocalTime.of(14, 30);

    // –í—Ç–æ—Ä–∞ —Å–º—è–Ω–∞: 13:30 - 22:00 (8.5 —á–∞—Å–∞ —Å 30 –º–∏–Ω –ø–æ—á–∏–≤–∫–∞)
    private static final LocalTime SECOND_SHIFT_START = LocalTime.of(13, 30);
    private static final LocalTime SECOND_SHIFT_END = LocalTime.of(22, 0);

    // –ú–µ–∂–¥–∏–Ω–Ω–∞ —Å–º—è–Ω–∞: 09:30 - 18:00 (8.5 —á–∞—Å–∞ —Å 30 –º–∏–Ω –ø–æ—á–∏–≤–∫–∞)
    private static final LocalTime INTERMEDIATE_SHIFT_START = LocalTime.of(9, 30);
    private static final LocalTime INTERMEDIATE_SHIFT_END = LocalTime.of(18, 0);

    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
    private static final int MAX_CONSECUTIVE_WORK_DAYS = 6; // –ú–∞–∫—Å–∏–º—É–º 6 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏
    private static final int MIN_REST_HOURS = 12; // –ú–∏–Ω–∏–º—É–º 12 —á–∞—Å–∞ –ø–æ—á–∏–≤–∫–∞ –º–µ–∂–¥—É —Å–º–µ–Ω–∏

    /**
     * –ì–õ–ê–í–ù–ê –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ–Ω –≥—Ä–∞—Ñ–∏–∫ –∑–∞ –¥–∞–¥–µ–Ω –º–µ—Å–µ—Ü
     *
     * @param year –≥–æ–¥–∏–Ω–∞
     * @param month –º–µ—Å–µ—Ü (1-12)
     * @return —Å—ä–æ–±—â–µ–Ω–∏–µ –∑–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞
     */
    @Transactional
    public String generateMonthlySchedule(int year, int month) {
        System.out.println("========================================");
        System.out.println("üöÄ –°–¢–ê–†–¢–ò–†–ê–ù–ï –ù–ê –ê–í–¢–û–ú–ê–¢–ò–ß–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù–ï –ù–ê –ì–†–ê–§–ò–ö");
        System.out.println("üìÖ –ú–µ—Å–µ—Ü: " + month + "/" + year);
        System.out.println("========================================");

        try {
            // –°–¢–™–ü–ö–ê 1: –ò–∑—Ç—Ä–∏–≤–∞–º–µ —Å—Ç–∞—Ä–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ –º–µ—Å–µ—Ü–∞
            deleteAutoGeneratedShifts(year, month);

            // –°–¢–™–ü–ö–ê 2: –ó–∞—Ä–µ–∂–¥–∞–º–µ –≤—Å–∏—á–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∏ —Ç–µ—Ö–Ω–∏—Ç–µ –¥–æ–≥–æ–≤–æ—Ä–∏
            List<Employee> employees = employeeRepository.findAll();
            if (employees.isEmpty()) {
                return "–ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∑–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫";
            }

            System.out.println("üìä –ù–∞–º–µ—Ä–µ–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏: " + employees.size());

            // –°–¢–™–ü–ö–ê 3: –ó–∞—Ä–µ–∂–¥–∞–º–µ —Ä—ä—á–Ω–æ –≤—ä–≤–µ–¥–µ–Ω–∏—Ç–µ —Å–º–µ–Ω–∏ (—Ç–µ –∏–º–∞—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
            Map<Long, List<Event>> manualShiftsByEmployee = loadManualShifts(year, month);
            System.out.println("‚úã –†—ä—á–Ω–æ –≤—ä–≤–µ–¥–µ–Ω–∏ —Å–º–µ–Ω–∏: " +
                    manualShiftsByEmployee.values().stream().mapToInt(List::size).sum());

            // –°–¢–™–ü–ö–ê 4: –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –≥—Ä–∞—Ñ–∏–∫ –∑–∞ –≤—Å–µ–∫–∏ –¥–µ–Ω –æ—Ç –º–µ—Å–µ—Ü–∞
            LocalDate startDate = LocalDate.of(year, month, 1);
            LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth());

            // –°—ä–∑–¥–∞–≤–∞–º–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—Ç–µ —Å–º–µ–Ω–∏
            List<Event> generatedShifts = new ArrayList<>();

            // –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –≤—Å–µ–∫–∏ –¥–µ–Ω –æ—Ç –º–µ—Å–µ—Ü–∞
            LocalDate currentDate = startDate;
            while (!currentDate.isAfter(endDate)) {
                System.out.println("\nüìÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –¥–∞—Ç–∞: " + currentDate);

                // –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ —Å–º–µ–Ω–∏ –∑–∞ —Ç–µ–∫—É—â–∏—è –¥–µ–Ω
                List<Event> dailyShifts = generateDailyShifts(
                        currentDate,
                        employees,
                        manualShiftsByEmployee,
                        generatedShifts
                );

                generatedShifts.addAll(dailyShifts);
                currentDate = currentDate.plusDays(1);
            }

            // –°–¢–™–ü–ö–ê 5: –ó–∞–ø–∏—Å–≤–∞–º–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—Ç–µ —Å–º–µ–Ω–∏ –≤ –±–∞–∑–∞—Ç–∞ –¥–∞–Ω–Ω–∏
            for (Event shift : generatedShifts) {
                shift.setIsAutoGenerated(true);
                eventRepository.save(shift);
            }

            System.out.println("\n========================================");
            System.out.println("‚úÖ –£–°–ü–ï–®–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù –ì–†–ê–§–ò–ö");
            System.out.println("üìä –û–±—â–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏: " + generatedShifts.size());
            System.out.println("========================================");

            return "–£—Å–ø–µ—à–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω –≥—Ä–∞—Ñ–∏–∫ –∑–∞ " + month + "/" + year +
                    ". –°—ä–∑–¥–∞–¥–µ–Ω–∏ " + generatedShifts.size() + " —Å–º–µ–Ω–∏.";

        } catch (Exception e) {
            System.err.println("‚ùå –ì–†–ï–®–ö–ê –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫: " + e.getMessage());
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä–∞ —Å–º–µ–Ω–∏ –∑–∞ –µ–¥–∏–Ω –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω –¥–µ–Ω
     * –¢–æ–≤–∞ –µ —Å—ä—Ä—Ü–µ—Ç–æ –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç—ä–º–∞ - —Ç—É–∫ —Å–µ –ø—Ä–∏–ª–∞–≥–∞—Ç –≤—Å–∏—á–∫–∏ –ø—Ä–∞–≤–∏–ª–∞
     */
    private List<Event> generateDailyShifts(
            LocalDate date,
            List<Employee> allEmployees,
            Map<Long, List<Event>> manualShifts,
            List<Event> previouslyGenerated) {

        List<Event> dailyShifts = new ArrayList<>();

        // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≤—Å–µ–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª
        List<EmployeeScheduleInfo> employeeInfos = prepareEmployeeInfo(
                allEmployees, date, manualShifts, previouslyGenerated
        );

        // –°–æ—Ä—Ç–∏—Ä–∞–º–µ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
        // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–º–∞—Ç —Ç–µ–∑–∏ —Å –ø–æ-–º–∞–ª–∫–æ –æ—Ç—Ä–∞–±–æ—Ç–µ–Ω–∏ —á–∞—Å–æ–≤–µ –∏ –ø–æ-–≥–æ–ª—è–º –¥–æ–≥–æ–≤–æ—Ä
        employeeInfos.sort((a, b) -> {
            // –ü—ä—Ä–≤–æ —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –Ω–∞ –ø–æ–∫—Ä–∏—Ç–∏–µ –Ω–∞ –º–µ—Å–µ—á–Ω–∞—Ç–∞ –Ω–æ—Ä–º–∞
            double coverageA = a.getMonthlyHoursCoverage();
            double coverageB = b.getMonthlyHoursCoverage();
            return Double.compare(coverageA, coverageB);
        });

        // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∫–æ–ª–∫–æ —Å–ª—É–∂–∏—Ç–µ–ª–∏ —Å–∞ –Ω—É–∂–Ω–∏ –∑–∞ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
        int totalAvailable = (int) employeeInfos.stream()
                .filter(EmployeeScheduleInfo::canWorkToday)
                .count();

        System.out.println("üë• –ù–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∑–∞ –¥–µ–Ω—è: " + totalAvailable);

        if (totalAvailable == 0) {
            System.out.println("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∑–∞ " + date);
            return dailyShifts;
        }

        // –†–∞–∑–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ –ø–æ —Å–º–µ–Ω–∏
        int firstShiftCount = Math.max(1, totalAvailable / 3);
        int secondShiftCount = Math.max(1, totalAvailable / 3);
        int intermediateShiftCount = Math.max(1, totalAvailable - firstShiftCount - secondShiftCount);

        // –ë–∞–ª–∞–Ω—Å–∏—Ä–∞–º–µ –±—Ä–æ—è –Ω–∞ –ø—ä—Ä–≤–∞ –∏ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞
        if (Math.abs(firstShiftCount - secondShiftCount) > 1) {
            int avg = (firstShiftCount + secondShiftCount) / 2;
            firstShiftCount = avg;
            secondShiftCount = avg;
            intermediateShiftCount = totalAvailable - firstShiftCount - secondShiftCount;
        }

        System.out.println("üìä –†–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: –ü—ä—Ä–≤–∞=" + firstShiftCount +
                ", –í—Ç–æ—Ä–∞=" + secondShiftCount +
                ", –ú–µ–∂–¥–∏–Ω–Ω–∞=" + intermediateShiftCount);

        // –ù–∞–∑–Ω–∞—á–∞–≤–∞–º–µ —Å–º–µ–Ω–∏ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ
        int assigned = 0;
        for (EmployeeScheduleInfo info : employeeInfos) {
            if (!info.canWorkToday()) {
                System.out.println("‚ùå " + info.employee.getName() + " –Ω–µ –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –¥–Ω–µ—Å");
                continue;
            }

            Event shift = null;

            // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∫–æ—è —Å–º—è–Ω–∞ –µ –Ω–∞–π-–ø–æ–¥—Ö–æ–¥—è—â–∞ –∑–∞ —Å–ª—É–∂–∏—Ç–µ–ª—è
            if (assigned < firstShiftCount && info.canWorkShift("FIRST", date)) {
                shift = createShift(info.employee, date, "FIRST");
            } else if (assigned < firstShiftCount + secondShiftCount && info.canWorkShift("SECOND", date)) {
                shift = createShift(info.employee, date, "SECOND");
            } else if (assigned < totalAvailable && info.canWorkShift("INTERMEDIATE", date)) {
                shift = createShift(info.employee, date, "INTERMEDIATE");
            }

            if (shift != null) {
                dailyShifts.add(shift);
                assigned++;
                System.out.println("‚úÖ –ù–∞–∑–Ω–∞—á–µ–Ω " + info.employee.getName() +
                        " –Ω–∞ " + shift.getActivity() + " —Å–º—è–Ω–∞");
            }

            // –ê–∫–æ —Å–º–µ –Ω–∞–∑–Ω–∞—á–∏–ª–∏ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ —Ö–æ—Ä–∞, —Å–ø–∏—Ä–∞–º–µ
            if (assigned >= totalAvailable) {
                break;
            }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –∏–º–∞–º–µ –ø–æ–Ω–µ –ø–æ –µ–¥–∏–Ω —á–æ–≤–µ–∫ –Ω–∞ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
        ensureMinimumCoverage(dailyShifts, employeeInfos, date);

        return dailyShifts;
    }

    /**
     * –ü–æ–¥–≥–æ—Ç–≤—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≤—Å–µ–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª -
     * –∫–æ–ª–∫–æ —á–∞—Å–∞ –µ —Ä–∞–±–æ—Ç–∏–ª, –∫–æ–≥–∞ –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –∏ —Ç.–Ω.
     */
    private List<EmployeeScheduleInfo> prepareEmployeeInfo(
            List<Employee> employees,
            LocalDate targetDate,
            Map<Long, List<Event>> manualShifts,
            List<Event> generatedShifts) {

        List<EmployeeScheduleInfo> infos = new ArrayList<>();

        for (Employee employee : employees) {
            EmployeeScheduleInfo info = new EmployeeScheduleInfo();
            info.employee = employee;

            // –°—ä–±–∏—Ä–∞–º–µ –≤—Å–∏—á–∫–∏ —Å–º–µ–Ω–∏ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª—è (—Ä—ä—á–Ω–∏ + –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏)
            List<Event> allShifts = new ArrayList<>();

            // –î–æ–±–∞–≤—è–º–µ —Ä—ä—á–Ω–∏—Ç–µ —Å–º–µ–Ω–∏
            if (manualShifts.containsKey(employee.getId())) {
                allShifts.addAll(manualShifts.get(employee.getId()));
            }

            // –î–æ–±–∞–≤—è–º–µ –≤–µ—á–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—Ç–µ —Å–º–µ–Ω–∏
            allShifts.addAll(
                    generatedShifts.stream()
                            .filter(s -> s.getEmployee().getId().equals(employee.getId()))
                            .collect(Collectors.toList())
            );

            // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            info.calculateStats(allShifts, targetDate);

            infos.add(info);
        }

        return infos;
    }

    /**
     * –°—ä–∑–¥–∞–≤–∞ —Å–º—è–Ω–∞ –∑–∞ —Å–ª—É–∂–∏—Ç–µ–ª
     */
    private Event createShift(Employee employee, LocalDate date, String shiftType) {
        Event shift = new Event();
        shift.setEmployee(employee);
        shift.setActivity(shiftType);
        shift.setIsAutoGenerated(true);

        // –û–ø—Ä–µ–¥–µ–ª—è–º–µ —á–∞—Å–æ–≤–µ—Ç–µ —Å–ø–æ—Ä–µ–¥ —Ç–∏–ø–∞ —Å–º—è–Ω–∞
        LocalTime startTime, endTime;
        String title;

        switch (shiftType) {
            case "FIRST":
                startTime = FIRST_SHIFT_START;
                endTime = FIRST_SHIFT_END;
                title = "–ü—ä—Ä–≤–∞ —Å–º—è–Ω–∞";
                break;
            case "SECOND":
                startTime = SECOND_SHIFT_START;
                endTime = SECOND_SHIFT_END;
                title = "–í—Ç–æ—Ä–∞ —Å–º—è–Ω–∞";
                break;
            case "INTERMEDIATE":
                startTime = INTERMEDIATE_SHIFT_START;
                endTime = INTERMEDIATE_SHIFT_END;
                title = "–ú–µ–∂–¥–∏–Ω–Ω–∞ —Å–º—è–Ω–∞";
                break;
            default:
                throw new IllegalArgumentException("–ù–µ–≤–∞–ª–∏–¥–µ–Ω —Ç–∏–ø —Å–º—è–Ω–∞: " + shiftType);
        }

        shift.setTitle(title + " - " + employee.getName());
        shift.setStart(LocalDateTime.of(date, startTime));
        shift.setEnd(LocalDateTime.of(date, endTime));

        return shift;
    }

    /**
     * –û—Å–∏–≥—É—Ä—è–≤–∞ –º–∏–Ω–∏–º–∞–ª–Ω–æ –ø–æ–∫—Ä–∏—Ç–∏–µ - –ø–æ–Ω–µ –µ–¥–∏–Ω —á–æ–≤–µ–∫ –Ω–∞ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
     */
    private void ensureMinimumCoverage(
            List<Event> dailyShifts,
            List<EmployeeScheduleInfo> employeeInfos,
            LocalDate date) {

        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –∫–æ–∏ —Å–º–µ–Ω–∏ –ª–∏–ø—Å–≤–∞—Ç
        boolean hasFirst = dailyShifts.stream()
                .anyMatch(s -> "FIRST".equals(s.getActivity()));
        boolean hasSecond = dailyShifts.stream()
                .anyMatch(s -> "SECOND".equals(s.getActivity()));
        boolean hasIntermediate = dailyShifts.stream()
                .anyMatch(s -> "INTERMEDIATE".equals(s.getActivity()));

        // –û–ø–∏—Ç–≤–∞–º–µ —Å–µ –¥–∞ –¥–æ–±–∞–≤–∏–º –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ —Å–º–µ–Ω–∏
        if (!hasFirst) {
            addMissingShift("FIRST", employeeInfos, dailyShifts, date);
        }
        if (!hasSecond) {
            addMissingShift("SECOND", employeeInfos, dailyShifts, date);
        }
        if (!hasIntermediate) {
            addMissingShift("INTERMEDIATE", employeeInfos, dailyShifts, date);
        }
    }
    /**
     * –î–æ–±–∞–≤—è –ª–∏–ø—Å–≤–∞—â–∞ —Å–º—è–Ω–∞ –∫–∞—Ç–æ –Ω–∞–º–∏—Ä–∞ –ø–æ–¥—Ö–æ–¥—è—â —Å–ª—É–∂–∏—Ç–µ–ª
     */
    private void addMissingShift(
            String shiftType,
            List<EmployeeScheduleInfo> employeeInfos,
            List<Event> dailyShifts,
            LocalDate date) {

        System.out.println("‚ö†Ô∏è –¢—ä—Ä—Å–∏–º —Å–ª—É–∂–∏—Ç–µ–ª –∑–∞ –ª–∏–ø—Å–≤–∞—â–∞ " + shiftType + " —Å–º—è–Ω–∞");

        // –¢—ä—Ä—Å–∏–º —Å–ª—É–∂–∏—Ç–µ–ª –∫–æ–π—Ç–æ –æ—â–µ –Ω–µ –µ –Ω–∞–∑–Ω–∞—á–µ–Ω –∑–∞ –¥–µ–Ω—è
        Set<Long> assignedEmployeeIds = dailyShifts.stream()
                .map(s -> s.getEmployee().getId())
                .collect(Collectors.toSet());

        for (EmployeeScheduleInfo info : employeeInfos) {
            if (!assignedEmployeeIds.contains(info.employee.getId()) &&
                    info.canWorkShift(shiftType, date)) {

                Event shift = createShift(info.employee, date, shiftType);
                dailyShifts.add(shift);
                System.out.println("‚úÖ –î–æ–±–∞–≤–µ–Ω " + info.employee.getName() +
                        " –∑–∞ –ø–æ–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ " + shiftType + " —Å–º—è–Ω–∞");
                break;
            }
        }
    }

    /**
     * –ò–∑—Ç—Ä–∏–≤–∞ —Å—Ç–∞—Ä–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏
     */
    private void deleteAutoGeneratedShifts(int year, int month) {
        LocalDate startDate = LocalDate.of(year, month, 1);
        LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth());

        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);

        List<Event> autoGeneratedShifts = eventRepository.findAll().stream()
                .filter(e -> e.getIsAutoGenerated() != null && e.getIsAutoGenerated())
                .filter(e -> !e.getStart().isBefore(startDateTime) && !e.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        System.out.println("üóëÔ∏è –ò–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ " + autoGeneratedShifts.size() +
                " —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏");

        eventRepository.deleteAll(autoGeneratedShifts);
    }

    /**
     * –ó–∞—Ä–µ–∂–¥–∞ —Ä—ä—á–Ω–æ –≤—ä–≤–µ–¥–µ–Ω–∏—Ç–µ —Å–º–µ–Ω–∏ –∑–∞ –º–µ—Å–µ—Ü–∞
     */
    private Map<Long, List<Event>> loadManualShifts(int year, int month) {
        LocalDate startDate = LocalDate.of(year, month, 1);
        LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth());

        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);

        List<Event> manualShifts = eventRepository.findAll().stream()
                .filter(e -> e.getIsAutoGenerated() == null || !e.getIsAutoGenerated())
                .filter(e -> !e.getStart().isBefore(startDateTime) && !e.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        // –ì—Ä—É–ø–∏—Ä–∞–º–µ –ø–æ —Å–ª—É–∂–∏—Ç–µ–ª
        return manualShifts.stream()
                .collect(Collectors.groupingBy(e -> e.getEmployee().getId()));
    }

    /**
     * –í—ä—Ç—Ä–µ—à–µ–Ω –∫–ª–∞—Å –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≥—Ä–∞—Ñ–∏–∫–∞ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª
     */
    private class EmployeeScheduleInfo {
        Employee employee;
        int totalMonthlyHours = 0;
        int consecutiveWorkDays = 0;
        LocalDate lastWorkDate = null;
        Event lastShift = null;
        List<Event> monthlyShifts = new ArrayList<>();

        /**
         * –ò–∑—á–∏—Å–ª—è–≤–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏—Ç–µ –∑–∞ —Å–ª—É–∂–∏—Ç–µ–ª—è
         */
        void calculateStats(List<Event> shifts, LocalDate targetDate) {
            // –§–∏–ª—Ç—Ä–∏—Ä–∞–º–µ —Å–º–µ–Ω–∏—Ç–µ –∑–∞ —Ç–µ–∫—É—â–∏—è –º–µ—Å–µ—Ü
            monthlyShifts = shifts.stream()
                    .filter(s -> s.getStart().getMonth() == targetDate.getMonth())
                    .sorted(Comparator.comparing(Event::getStart))
                    .collect(Collectors.toList());

            // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –æ–±—â–∏—Ç–µ —á–∞—Å–æ–≤–µ –∑–∞ –º–µ—Å–µ—Ü–∞
            for (Event shift : monthlyShifts) {
                long hours = ChronoUnit.HOURS.between(shift.getStart(), shift.getEnd());
                totalMonthlyHours += hours;
            }

            // –ù–∞–º–∏—Ä–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ —Å–º—è–Ω–∞ –∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –∑–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ –¥–Ω–∏
            if (!monthlyShifts.isEmpty()) {
                lastShift = monthlyShifts.get(monthlyShifts.size() - 1);
                lastWorkDate = lastShift.getStart().toLocalDate();

                // –ë—Ä–æ–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏—Ç–µ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏ –Ω–∞–∑–∞–¥ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∞—Ç–∞
                consecutiveWorkDays = countConsecutiveWorkDays(shifts, lastWorkDate);
            }
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ —Å–ª—É–∂–∏—Ç–µ–ª—è—Ç –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –¥–Ω–µ—Å
         */
        boolean canWorkToday() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –ú–∞–∫—Å–∏–º—É–º 6 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏
            if (consecutiveWorkDays >= MAX_CONSECUTIVE_WORK_DAYS) {
                return false;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –º–µ—Å–µ—á–Ω–∞—Ç–∞ –Ω–æ—Ä–º–∞
            Integer contractHours = employee.getHourlyRate();
            if (contractHours == null) contractHours = 8;

            int maxMonthlyHours = getMaxMonthlyHours(contractHours);
            if (totalMonthlyHours >= maxMonthlyHours) {
                return false;
            }

            return true;
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ —Å–ª—É–∂–∏—Ç–µ–ª—è—Ç –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ —Å–º—è–Ω–∞
         */
        boolean canWorkShift(String shiftType, LocalDate date) {
            if (!canWorkToday()) return false;

            // –ê–∫–æ –Ω—è–º–∞ –ø—Ä–µ–¥–∏—à–Ω–∞ —Å–º—è–Ω–∞, –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
            if (lastShift == null) return true;

            // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ
            LocalDateTime newShiftStart;
            switch (shiftType) {
                case "FIRST":
                    newShiftStart = LocalDateTime.of(date, FIRST_SHIFT_START);
                    break;
                case "SECOND":
                    newShiftStart = LocalDateTime.of(date, SECOND_SHIFT_START);
                    break;
                case "INTERMEDIATE":
                    newShiftStart = LocalDateTime.of(date, INTERMEDIATE_SHIFT_START);
                    break;
                default:
                    return false;
            }

            long hoursSinceLastShift = ChronoUnit.HOURS.between(
                    lastShift.getEnd(), newShiftStart
            );

            return hoursSinceLastShift >= MIN_REST_HOURS;
        }

        /**
         * –ò–∑—á–∏—Å–ª—è–≤–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –Ω–∞ –ø–æ–∫—Ä–∏—Ç–∏–µ –Ω–∞ –º–µ—Å–µ—á–Ω–∞—Ç–∞ –Ω–æ—Ä–º–∞
         */
        double getMonthlyHoursCoverage() {
            Integer contractHours = employee.getHourlyRate();
            if (contractHours == null) contractHours = 8;

            int targetMonthlyHours = getTargetMonthlyHours(contractHours);
            if (targetMonthlyHours == 0) return 0;

            return (double) totalMonthlyHours / targetMonthlyHours;
        }

        /**
         * –ë—Ä–æ–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏—Ç–µ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏
         */
        private int countConsecutiveWorkDays(List<Event> shifts, LocalDate fromDate) {
            int count = 0;
            LocalDate checkDate = fromDate;

            while (true) {
                LocalDate finalCheckDate = checkDate;
                boolean hasShiftOnDate = shifts.stream()
                        .anyMatch(s -> s.getStart().toLocalDate().equals(finalCheckDate));

                if (hasShiftOnDate) {
                    count++;
                    checkDate = checkDate.minusDays(1);
                } else {
                    break;
                }
            }

            return count;
        }
    }

    /**
     * –í—Ä—ä—â–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–∏—Ç–µ –º–µ—Å–µ—á–Ω–∏ —á–∞—Å–æ–≤–µ —Å–ø–æ—Ä–µ–¥ –¥–æ–≥–æ–≤–æ—Ä–∞
     */
    private int getMaxMonthlyHours(int contractHoursPerDay) {
        switch (contractHoursPerDay) {
            case 4:
                return 100; // –ú–∞–ª–∫–æ –ø–æ–≤–µ—á–µ –æ—Ç 80 —á–∞—Å–∞
            case 6:
                return 140; // –ú–∞–ª–∫–æ –ø–æ–≤–µ—á–µ –æ—Ç 120 —á–∞—Å–∞
            case 8:
                return 184; // –ú–∞–ª–∫–æ –ø–æ–≤–µ—á–µ –æ—Ç 160 —á–∞—Å–∞
            default:
                return 160;
        }
    }

    /**
     * –í—Ä—ä—â–∞ —Ü–µ–ª–µ–≤–∏—Ç–µ –º–µ—Å–µ—á–Ω–∏ —á–∞—Å–æ–≤–µ —Å–ø–æ—Ä–µ–¥ –¥–æ–≥–æ–≤–æ—Ä–∞
     */
    private int getTargetMonthlyHours(int contractHoursPerDay) {
        switch (contractHoursPerDay) {
            case 4:
                return 80;
            case 6:
                return 120;
            case 8:
                return 160;
            default:
                return 160;
        }
    }

    // ========================================
    // –î–û–ü–™–õ–ù–ò–¢–ï–õ–ù–ò –ú–ï–¢–û–î–ò –ó–ê –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø
    // ========================================

    /**
     * –ë–∞–ª–∞–Ω—Å–∏—Ä–∞ —Å–º–µ–Ω–∏—Ç–µ –º–µ–∂–¥—É —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ
     * –ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞ —á–µ –≤—Å–µ–∫–∏ –∏–º–∞ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ —Ä–∞–≤–µ–Ω –±—Ä–æ–π –ø—ä—Ä–≤–∏, –≤—Ç–æ—Ä–∏ –∏ –º–µ–∂–¥–∏–Ω–Ω–∏ —Å–º–µ–Ω–∏
     */
    private void balanceShiftTypes(List<EmployeeScheduleInfo> employeeInfos) {
        Map<Long, Map<String, Integer>> shiftCounts = new HashMap<>();

        // –ë—Ä–æ–∏–º –∫–æ–ª–∫–æ –æ—Ç –≤—Å–µ–∫–∏ —Ç–∏–ø —Å–º—è–Ω–∞ –∏–º–∞ –≤—Å–µ–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª
        for (EmployeeScheduleInfo info : employeeInfos) {
            Map<String, Integer> counts = new HashMap<>();
            counts.put("FIRST", 0);
            counts.put("SECOND", 0);
            counts.put("INTERMEDIATE", 0);

            for (Event shift : info.monthlyShifts) {
                String type = shift.getActivity();
                counts.put(type, counts.get(type) + 1);
            }

            shiftCounts.put(info.employee.getId(), counts);
        }

        // –õ–æ–≥–∏–∫–∞—Ç–∞ –∑–∞ –±–∞–ª–∞–Ω—Å–∏—Ä–∞–Ω–µ –º–æ–∂–µ –¥–∞ —Å–µ —Ä–∞–∑—à–∏—Ä–∏ —Ç—É–∫
        System.out.println("üìä –ë–∞–ª–∞–Ω—Å –Ω–∞ —Å–º–µ–Ω–∏—Ç–µ –ø–æ —Ç–∏–ø:");
        for (EmployeeScheduleInfo info : employeeInfos) {
            Map<String, Integer> counts = shiftCounts.get(info.employee.getId());
            System.out.println("   " + info.employee.getName() + ": " +
                    "–ü—ä—Ä–≤–∞=" + counts.get("FIRST") + ", " +
                    "–í—Ç–æ—Ä–∞=" + counts.get("SECOND") + ", " +
                    "–ú–µ–∂–¥–∏–Ω–Ω–∞=" + counts.get("INTERMEDIATE"));
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—è—Ç –≥—Ä–∞—Ñ–∏–∫ –µ –≤–∞–ª–∏–¥–µ–Ω
     * –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ —Ñ–∏–Ω–∞–ª–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–¥–∏ –∑–∞–ø–∏—Å–≤–∞–Ω–µ
     */
    private boolean validateGeneratedSchedule(List<Event> generatedShifts) {
        System.out.println("üîç –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫...");

        // –ì—Ä—É–ø–∏—Ä–∞–º–µ –ø–æ —Å–ª—É–∂–∏—Ç–µ–ª
        Map<Long, List<Event>> shiftsByEmployee = generatedShifts.stream()
                .collect(Collectors.groupingBy(e -> e.getEmployee().getId()));

        for (Map.Entry<Long, List<Event>> entry : shiftsByEmployee.entrySet()) {
            List<Event> employeeShifts = entry.getValue();
            employeeShifts.sort(Comparator.comparing(Event::getStart));

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: 12 —á–∞—Å–∞ –ø–æ—á–∏–≤–∫–∞ –º–µ–∂–¥—É —Å–º–µ–Ω–∏
            for (int i = 1; i < employeeShifts.size(); i++) {
                Event previousShift = employeeShifts.get(i - 1);
                Event currentShift = employeeShifts.get(i);

                long hoursBetween = ChronoUnit.HOURS.between(
                        previousShift.getEnd(), currentShift.getStart()
                );

                if (hoursBetween < MIN_REST_HOURS) {
                    System.err.println("‚ùå –ù–∞—Ä—É—à–µ–Ω–æ 12-—á–∞—Å–æ–≤–æ –ø—Ä–∞–≤–∏–ª–æ –∑–∞ –ø–æ—á–∏–≤–∫–∞!");
                    return false;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –ú–∞–∫—Å–∏–º—É–º 6 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏
            int consecutiveDays = 1;
            LocalDate lastDate = employeeShifts.get(0).getStart().toLocalDate();

            for (int i = 1; i < employeeShifts.size(); i++) {
                LocalDate currentDate = employeeShifts.get(i).getStart().toLocalDate();

                if (currentDate.equals(lastDate.plusDays(1))) {
                    consecutiveDays++;
                    if (consecutiveDays > MAX_CONSECUTIVE_WORK_DAYS) {
                        System.err.println("‚ùå –ù–∞–¥–≤–∏—à–µ–Ω –º–∞–∫—Å–∏–º—É–º –æ—Ç 6 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏!");
                        return false;
                    }
                } else {
                    consecutiveDays = 1;
                }

                lastDate = currentDate;
            }
        }

        System.out.println("‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è—Ç–∞ –ø—Ä–µ–º–∏–Ω–∞ —É—Å–ø–µ—à–Ω–æ!");
        return true;
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å—ä–∑–¥–∞–¥–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫
     */
    public Map<String, Object> generateScheduleStatistics(int year, int month) {
        Map<String, Object> stats = new HashMap<>();

        LocalDate startDate = LocalDate.of(year, month, 1);
        LocalDate endDate = startDate.withDayOfMonth(startDate.lengthOfMonth());

        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(23, 59, 59);

        List<Event> allEvents = eventRepository.findAll().stream()
                .filter(e -> !e.getStart().isBefore(startDateTime) && !e.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        long autoGenerated = allEvents.stream()
                .filter(e -> e.getIsAutoGenerated() != null && e.getIsAutoGenerated())
                .count();

        long manual = allEvents.size() - autoGenerated;

        stats.put("totalShifts", allEvents.size());
        stats.put("autoGeneratedShifts", autoGenerated);
        stats.put("manualShifts", manual);
        stats.put("month", month);
        stats.put("year", year);

        return stats;
    }
}
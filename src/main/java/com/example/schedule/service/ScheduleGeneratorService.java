package com.example.schedule.service;

import com.example.schedule.entity.Employee;
import com.example.schedule.entity.Event;
import com.example.schedule.repository.EmployeeRepository;
import com.example.schedule.repository.EventRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.DayOfWeek;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ScheduleGeneratorService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private EventRepository eventRepository;

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∑–∞ —Å–º–µ–Ω–∏—Ç–µ
    private static final LocalTime FIRST_SHIFT_START = LocalTime.of(6, 0);
    private static final LocalTime FIRST_SHIFT_END = LocalTime.of(14, 30);

    private static final LocalTime SECOND_SHIFT_START = LocalTime.of(13, 30);
    private static final LocalTime SECOND_SHIFT_END = LocalTime.of(22, 0);

    private static final LocalTime MIDDLE_SHIFT_START = LocalTime.of(9, 30);
    private static final LocalTime MIDDLE_SHIFT_END = LocalTime.of(18, 0);

    // –ï–Ω—É–º –∑–∞ —Ç–∏–ø–æ–≤–µ—Ç–µ —Å–º–µ–Ω–∏
    public enum ShiftType {
        FIRST("First Shift", FIRST_SHIFT_START, FIRST_SHIFT_END),
        SECOND("Second Shift", SECOND_SHIFT_START, SECOND_SHIFT_END),
        MIDDLE("Middle Shift", MIDDLE_SHIFT_START, MIDDLE_SHIFT_END);

        private final String name;
        private final LocalTime startTime;
        private final LocalTime endTime;

        ShiftType(String name, LocalTime startTime, LocalTime endTime) {
            this.name = name;
            this.startTime = startTime;
            this.endTime = endTime;
        }

        public String getName() { return name; }
        public LocalTime getStartTime() { return startTime; }
        public LocalTime getEndTime() { return endTime; }
    }

    /**
     * –ì–õ–ê–í–ù–ê –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥—Ä–∞—Ñ–∏–∫ –∑–∞ –º–µ—Å–µ—Ü–∞
     * –û–ë–ù–û–í–ï–ù–ê –ó–ê 7-–î–ù–ï–í–ù–ê –†–ê–ë–û–¢–ê –ò –ë–ê–õ–ê–ù–°–ò–†–ê–ù–ò –°–ú–ï–ù–ò
     */
    @Transactional
    public int generateMonthlySchedule(int year, int month) {
        System.out.println("üöÄ === –ó–ê–ü–û–ß–í–ê –ê–í–¢–û–ú–ê–¢–ò–ß–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù–ï –ù–ê 7-–î–ù–ï–í–ï–ù –ì–†–ê–§–ò–ö ===");
        System.out.println(String.format("üìÖ –ü–µ—Ä–∏–æ–¥: %02d/%d", month, year));

        // –°–¢–™–ü–ö–ê 1: –í–∑–µ–º–∞–º–µ –≤—Å–∏—á–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏
        List<Employee> allEmployees = employeeRepository.findAll();
        if (allEmployees.isEmpty()) {
            System.out.println("‚ùå –ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∑–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫");
            return 0;
        }
        System.out.println(String.format("üë• –ù–∞–º–µ—Ä–µ–Ω–∏ %d —Å–ª—É–∂–∏—Ç–µ–ª–∏", allEmployees.size()));

        // –°–¢–™–ü–ö–ê 2: –ò–∑—Ç—Ä–∏–≤–∞–º–µ —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ –º–µ—Å–µ—Ü–∞
        deleteAutoGeneratedShiftsForMonth(year, month);

        // –°–¢–™–ü–ö–ê 3: –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –í–°–ò–ß–ö–ò –¥–Ω–∏ –∑–∞ –º–µ—Å–µ—Ü–∞ (–±–µ–∑ –∏–∑–∫–ª—é—á–µ–Ω–∏—è)
        List<LocalDate> allDaysInMonth = generateAllDaysForMonth(year, month);
        System.out.println(String.format("üìä –ú–µ—Å–µ—Ü—ä—Ç –∏–º–∞ %d –¥–Ω–∏ (–≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ —É–∏–∫–µ–Ω–¥–∏)", allDaysInMonth.size()));

        // –°–¢–™–ü–ö–ê 4: –ü–æ–ª—É—á–∞–≤–∞–º–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏ —Ä—ä—á–Ω–æ —Å—ä–∑–¥–∞–¥–µ–Ω–∏ —Å–º–µ–Ω–∏
        Map<LocalDate, List<Event>> existingManualShifts = getExistingManualShiftsByDate(year, month);
        System.out.println(String.format("üìå –ù–∞–º–µ—Ä–µ–Ω–∏ —Ä—ä—á–Ω–æ —Å—ä–∑–¥–∞–¥–µ–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ %d –¥–Ω–∏", existingManualShifts.size()));

        // –°–¢–™–ü–ö–ê 5: –ê–Ω–∞–ª–∏–∑–∏—Ä–∞–º–µ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∞ –∏ –Ω—É–∂–¥–∏—Ç–µ
        ScheduleAnalysis analysis = analyzeSchedulingNeeds(allEmployees, allDaysInMonth, existingManualShifts);
        System.out.println(String.format("üìä –ê–Ω–∞–ª–∏–∑: %d –¥–Ω–∏ –∑–∞ –ø–æ–∫—Ä–∏–≤–∞–Ω–µ, %d –æ–±—â–æ —á–∞—Å–∞",
                analysis.getDaysToSchedule(), analysis.getTotalHoursNeeded()));

        // –°–¢–™–ü–ö–ê 6: –°—ä–∑–¥–∞–≤–∞–º–µ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –≥—Ä–∞—Ñ–∏–∫
        Map<LocalDate, DailySchedule> monthlySchedule = createOptimalMonthlySchedule(
                allEmployees, allDaysInMonth, existingManualShifts, analysis);

        // –°–¢–™–ü–ö–ê 7: –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å–º–µ–Ω–∏—Ç–µ
        List<Event> generatedShifts = createEventsFromSchedule(monthlySchedule);
        eventRepository.saveAll(generatedShifts);

        System.out.println(String.format("üéØ –ì–ï–ù–ï–†–ò–†–ê–ù–ï–¢–û –ó–ê–í–™–†–®–ò –£–°–ü–ï–®–ù–û! –û–±—â–æ —Å–º–µ–Ω–∏: %d", generatedShifts.size()));
        return generatedShifts.size();
    }

    /**
     * –ù–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –¥–Ω–∏ –≤ –º–µ—Å–µ—Ü–∞ (–≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ —É–∏–∫–µ–Ω–¥–∏)
     */
    private List<LocalDate> generateAllDaysForMonth(int year, int month) {
        List<LocalDate> allDays = new ArrayList<>();
        LocalDate date = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());

        while (!date.isAfter(endOfMonth)) {
            allDays.add(date);
            date = date.plusDays(1);
        }

        System.out.println(String.format("üìÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ %d –¥–Ω–∏: %s - %s",
                allDays.size(), allDays.get(0), allDays.get(allDays.size()-1)));
        return allDays;
    }

    /**
     * –ù–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–∞–≤–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏ –≥—Ä—É–ø–∏—Ä–∞–Ω–∏ –ø–æ –¥–Ω–∏
     */
    private Map<LocalDate, List<Event>> getExistingManualShiftsByDate(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> manualEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() == null || !event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .filter(event -> event.getLeaveType() == null) // –ò–∑–∫–ª—é—á–≤–∞–º–µ –æ—Ç–ø—É—Å–∫–∏
                .collect(Collectors.toList());

        return manualEvents.stream()
                .collect(Collectors.groupingBy(event -> event.getStart().toLocalDate()));
    }

    /**
     * –ù–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ê–Ω–∞–ª–∏–∑–∏—Ä–∞ –Ω—É–∂–¥–∏—Ç–µ –∑–∞ –ø–ª–∞–Ω–∏—Ä–∞–Ω–µ
     */
    private ScheduleAnalysis analyzeSchedulingNeeds(List<Employee> employees,
                                                    List<LocalDate> allDays,
                                                    Map<LocalDate, List<Event>> existingShifts) {

        ScheduleAnalysis analysis = new ScheduleAnalysis();

        // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –æ–±—â–∏—è –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ
        int totalEmployeeCapacity = 0;
        for (Employee emp : employees) {
            int contractHours = emp.getHourlyRate() != null ? emp.getHourlyRate() : 8;
            int daysPerWeek = Math.round((contractHours * 7) / 8.0f); // –ö–æ–ª–∫–æ –¥–Ω–∏ –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –≤ —Å–µ–¥–º–∏—Ü–∞
            int daysPerMonth = (daysPerWeek * allDays.size()) / 7;
            totalEmployeeCapacity += daysPerMonth;
        }

        // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –º–∏–Ω–∏–º–∞–ª–Ω–∏—Ç–µ –Ω—É–∂–¥–∏ (3 —Å–º–µ–Ω–∏ –Ω–∞ –¥–µ–Ω - 1 –ø—ä—Ä–≤–∞, 1 –≤—Ç–æ—Ä–∞, 1 –º–µ–∂–¥–∏–Ω–Ω–∞)
        int minShiftsNeeded = allDays.size() * 3;

        // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –æ–ø—Ç–∏–º–∞–ª–Ω–∏—Ç–µ –Ω—É–∂–¥–∏ (—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ)
        int optimalShiftsPerDay = Math.max(3, employees.size() / 3); // –ü–æ–Ω–µ 3, –∏–ª–∏ 1/3 –æ—Ç —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ
        int optimalTotalShifts = allDays.size() * optimalShiftsPerDay;

        analysis.setTotalEmployees(employees.size());
        analysis.setTotalDays(allDays.size());
        analysis.setEmployeeCapacity(totalEmployeeCapacity);
        analysis.setMinShiftsNeeded(minShiftsNeeded);
        analysis.setOptimalShiftsNeeded(Math.min(optimalTotalShifts, totalEmployeeCapacity));
        analysis.setExistingShifts(existingShifts.values().stream().mapToInt(List::size).sum());

        System.out.println(String.format("üìä –ê–Ω–∞–ª–∏–∑ –Ω–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∞:"));
        System.out.println(String.format("   üë• –°–ª—É–∂–∏—Ç–µ–ª–∏: %d", analysis.getTotalEmployees()));
        System.out.println(String.format("   üìÖ –î–Ω–∏: %d", analysis.getTotalDays()));
        System.out.println(String.format("   üí™ –ö–∞–ø–∞—Ü–∏—Ç–µ—Ç: %d —Å–º–µ–Ω–∏", analysis.getEmployeeCapacity()));
        System.out.println(String.format("   üéØ –ú–∏–Ω–∏–º—É–º: %d —Å–º–µ–Ω–∏", analysis.getMinShiftsNeeded()));
        System.out.println(String.format("   ‚≠ê –û–ø—Ç–∏–º—É–º: %d —Å–º–µ–Ω–∏", analysis.getOptimalShiftsNeeded()));
        System.out.println(String.format("   üìå –°—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏: %d —Å–º–µ–Ω–∏", analysis.getExistingShifts()));

        return analysis;
    }

    /**
     * –ö–õ–Æ–ß–û–í–ê –§–£–ù–ö–¶–ò–Ø: –°—ä–∑–¥–∞–≤–∞ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –º–µ—Å–µ—á–µ–Ω –≥—Ä–∞—Ñ–∏–∫
     */
    private Map<LocalDate, DailySchedule> createOptimalMonthlySchedule(
            List<Employee> employees,
            List<LocalDate> allDays,
            Map<LocalDate, List<Event>> existingShifts,
            ScheduleAnalysis analysis) {

        Map<LocalDate, DailySchedule> schedule = new HashMap<>();
        Map<Employee, Integer> employeeWorkDays = new HashMap<>();
        Map<Employee, Set<LocalDate>> employeeRestDays = new HashMap<>();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ –±—Ä–æ—è—á–∏ –∑–∞ –≤—Å–µ–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª
        for (Employee emp : employees) {
            employeeWorkDays.put(emp, 0);
            employeeRestDays.put(emp, new HashSet<>());
        }

        // –°–¢–™–ü–ö–ê 1: –°—ä–∑–¥–∞–≤–∞–º–µ —Ä–æ—Ç–∞—Ü–∏–æ–Ω–Ω–∞ —Å—Ö–µ–º–∞ –∑–∞ –ø–æ—á–∏–≤–Ω–∏—Ç–µ –¥–Ω–∏
        Map<Employee, Set<LocalDate>> rotationalRestDays = createRotationalRestDays(employees, allDays);

        // –°–¢–™–ü–ö–ê 2: –ó–∞ –≤—Å–µ–∫–∏ –¥–µ–Ω –ø–ª–∞–Ω–∏—Ä–∞–º–µ —Å–º–µ–Ω–∏—Ç–µ
        for (LocalDate day : allDays) {
            DailySchedule dailySchedule = planDailyShifts(day, employees, existingShifts.get(day),
                    rotationalRestDays, analysis);
            schedule.put(day, dailySchedule);

            // –û–±–Ω–æ–≤—è–≤–∞–º–µ –±—Ä–æ—è—á–∏—Ç–µ
            for (Employee emp : dailySchedule.getAllAssignedEmployees()) {
                employeeWorkDays.put(emp, employeeWorkDays.get(emp) + 1);
            }
        }

        // –°–¢–™–ü–ö–ê 3: –õ–æ–≥–≤–∞–º–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
        logScheduleResults(schedule, employeeWorkDays);

        return schedule;
    }

    /**
     * –ù–û–í–ê –§–£–ù–ö–¶–ò–Ø: –°—ä–∑–¥–∞–≤–∞ —Ä–æ—Ç–∞—Ü–∏–æ–Ω–Ω–∞ —Å—Ö–µ–º–∞ –∑–∞ –ø–æ—á–∏–≤–Ω–∏—Ç–µ –¥–Ω–∏
     */
    private Map<Employee, Set<LocalDate>> createRotationalRestDays(List<Employee> employees, List<LocalDate> allDays) {
        Map<Employee, Set<LocalDate>> restDays = new HashMap<>();

        // –†–∞–∑–ª–∏—á–Ω–∏ —à–∞–±–ª–æ–Ω–∏ –∑–∞ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏
        List<List<DayOfWeek>> restPatterns = Arrays.asList(
                Arrays.asList(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY),      // –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ —É–∏–∫–µ–Ω–¥
                Arrays.asList(DayOfWeek.MONDAY, DayOfWeek.TUESDAY),       // –ü–æ–Ω–µ–¥–µ–ª–Ω–∏–∫-–≤—Ç–æ—Ä–Ω–∏–∫
                Arrays.asList(DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY),   // –°—Ä—è–¥–∞-—á–µ—Ç–≤—ä—Ä—Ç—ä–∫
                Arrays.asList(DayOfWeek.FRIDAY, DayOfWeek.SATURDAY),      // –ü–µ—Ç—ä–∫-—Å—ä–±–æ—Ç–∞
                Arrays.asList(DayOfWeek.SUNDAY, DayOfWeek.MONDAY),        // –ù–µ–¥–µ–ª—è-–ø–æ–Ω–µ–¥–µ–ª–Ω–∏–∫
                Arrays.asList(DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY),    // –í—Ç–æ—Ä–Ω–∏–∫-—Å—Ä—è–¥–∞
                Arrays.asList(DayOfWeek.THURSDAY, DayOfWeek.FRIDAY)       // –ß–µ—Ç–≤—ä—Ä—Ç—ä–∫-–ø–µ—Ç—ä–∫
        );

        for (int i = 0; i < employees.size(); i++) {
            Employee emp = employees.get(i);
            List<DayOfWeek> pattern = restPatterns.get(i % restPatterns.size()); // –†–æ—Ç–∞—Ü–∏—è –Ω–∞ —à–∞–±–ª–æ–Ω–∏—Ç–µ

            Set<LocalDate> empRestDays = new HashSet<>();
            for (LocalDate day : allDays) {
                if (pattern.contains(day.getDayOfWeek())) {
                    empRestDays.add(day);
                }
            }

            restDays.put(emp, empRestDays);
            System.out.println(String.format("üë§ %s: –ø–æ—á–∏–≤–∞ %s (%d –¥–Ω–∏)",
                    emp.getName(), pattern, empRestDays.size()));
        }

        return restDays;
    }

    /**
     * –ö–õ–Æ–ß–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ü–ª–∞–Ω–∏—Ä–∞ —Å–º–µ–Ω–∏—Ç–µ –∑–∞ –µ–¥–∏–Ω –¥–µ–Ω
     */
    private DailySchedule planDailyShifts(LocalDate day,
                                          List<Employee> allEmployees,
                                          List<Event> existingShifts,
                                          Map<Employee, Set<LocalDate>> restDays,
                                          ScheduleAnalysis analysis) {

        DailySchedule dailySchedule = new DailySchedule(day);

        // –°–¢–™–ü–ö–ê 1: –î–æ–±–∞–≤—è–º–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏—Ç–µ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏
        if (existingShifts != null) {
            for (Event shift : existingShifts) {
                ShiftType type = determineShiftType(shift);
                dailySchedule.addExistingShift(shift.getEmployee(), type);
            }
        }

        // –°–¢–™–ü–ö–ê 2: –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∫–æ–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ —Å–∞ –Ω–∞–ª–∏—á–Ω–∏ –¥–Ω–µ—Å
        List<Employee> availableEmployees = allEmployees.stream()
                .filter(emp -> !restDays.getOrDefault(emp, Collections.emptySet()).contains(day))
                .filter(emp -> !dailySchedule.isEmployeeAlreadyScheduled(emp))
                .collect(Collectors.toList());

        // –°–¢–™–ü–ö–ê 3: –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –∫–æ–ª–∫–æ —Å–º–µ–Ω–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –¥–æ–±–∞–≤–∏–º
        int neededFirstShifts = Math.max(1, (availableEmployees.size() / 3)) - dailySchedule.getFirstShiftCount();
        int neededSecondShifts = Math.max(1, (availableEmployees.size() / 3)) - dailySchedule.getSecondShiftCount();
        int neededMiddleShifts = Math.max(1, 1) - dailySchedule.getMiddleShiftCount(); // –í–∏–Ω–∞–≥–∏ –ø–æ–Ω–µ 1

        // –°–¢–™–ü–ö–ê 4: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ –ø–æ —Å–º–µ–Ω–∏
        Collections.shuffle(availableEmployees); // –°–ª—É—á–∞–π–Ω–æ —Ä–∞–∑–±—ä—Ä–∫–≤–∞–Ω–µ –∑–∞ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç

        Iterator<Employee> empIterator = availableEmployees.iterator();

        // –ü—ä—Ä–≤–æ –¥–æ–±–∞–≤—è–º–µ –º–µ–∂–¥–∏–Ω–Ω–∏—Ç–µ —Å–º–µ–Ω–∏ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
        while (neededMiddleShifts > 0 && empIterator.hasNext()) {
            Employee emp = empIterator.next();
            dailySchedule.addGeneratedShift(emp, ShiftType.MIDDLE);
            neededMiddleShifts--;
        }

        // –°–ª–µ–¥ —Ç–æ–≤–∞ –±–∞–ª–∞–Ω—Å–∏—Ä–∞–º–µ –ø—ä—Ä–≤–∞ –∏ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞
        while ((neededFirstShifts > 0 || neededSecondShifts > 0) && empIterator.hasNext()) {
            Employee emp = empIterator.next();

            if (neededFirstShifts >= neededSecondShifts && neededFirstShifts > 0) {
                dailySchedule.addGeneratedShift(emp, ShiftType.FIRST);
                neededFirstShifts--;
            } else if (neededSecondShifts > 0) {
                dailySchedule.addGeneratedShift(emp, ShiftType.SECOND);
                neededSecondShifts--;
            }
        }

        System.out.println(String.format("üìÖ %s: %d –ø—ä—Ä–≤–∏, %d –≤—Ç–æ—Ä–∏, %d –º–µ–∂–¥–∏–Ω–Ω–∏ (–æ–±—â–æ %d)",
                day, dailySchedule.getFirstShiftCount(), dailySchedule.getSecondShiftCount(),
                dailySchedule.getMiddleShiftCount(), dailySchedule.getTotalShiftCount()));

        return dailySchedule;
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –û–ø—Ä–µ–¥–µ–ª—è —Ç–∏–ø–∞ —Å–º—è–Ω–∞ –ø–æ —á–∞—Å–æ–≤–µ
     */
    private ShiftType determineShiftType(Event event) {
        LocalTime startTime = event.getStart().toLocalTime();

        if (startTime.equals(FIRST_SHIFT_START)) return ShiftType.FIRST;
        if (startTime.equals(SECOND_SHIFT_START)) return ShiftType.SECOND;
        if (startTime.equals(MIDDLE_SHIFT_START)) return ShiftType.MIDDLE;

        // Fallback –ª–æ–≥–∏–∫–∞
        if (startTime.isBefore(LocalTime.of(10, 0))) return ShiftType.FIRST;
        if (startTime.isAfter(LocalTime.of(13, 0))) return ShiftType.SECOND;
        return ShiftType.MIDDLE;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –°—ä–∑–¥–∞–≤–∞ Event –æ–±–µ–∫—Ç–∏ –æ—Ç –ø–ª–∞–Ω–∏—Ä–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫
     */
    private List<Event> createEventsFromSchedule(Map<LocalDate, DailySchedule> schedule) {
        List<Event> events = new ArrayList<>();

        for (Map.Entry<LocalDate, DailySchedule> entry : schedule.entrySet()) {
            LocalDate date = entry.getKey();
            DailySchedule daily = entry.getValue();

            // –°—ä–∑–¥–∞–≤–∞–º–µ —Å—ä–±–∏—Ç–∏—è –∑–∞ –≤—Å–∏—á–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏
            for (Map.Entry<Employee, ShiftType> shiftEntry : daily.getGeneratedShifts().entrySet()) {
                Employee emp = shiftEntry.getKey();
                ShiftType shiftType = shiftEntry.getValue();

                Event event = new Event();
                event.setTitle(emp.getName().split(" ")[0]); // –ü—ä—Ä–≤–æ—Ç–æ –∏–º–µ
                event.setStart(date.atTime(shiftType.getStartTime()));
                event.setEnd(date.atTime(shiftType.getEndTime()));
                event.setActivity("Auto-generated " + shiftType.getName());
                event.setEmployee(emp);
                event.setIsAutoGenerated(true);

                events.add(event);
            }
        }

        return events;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –õ–æ–≥–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –æ—Ç –ø–ª–∞–Ω–∏—Ä–∞–Ω–µ—Ç–æ
     */
    private void logScheduleResults(Map<LocalDate, DailySchedule> schedule, Map<Employee, Integer> workDays) {
        System.out.println("\nüìä === –†–ï–ó–£–õ–¢–ê–¢–ò –û–¢ –ü–õ–ê–ù–ò–†–ê–ù–ï–¢–û ===");

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å–ª—É–∂–∏—Ç–µ–ª–∏
        for (Map.Entry<Employee, Integer> entry : workDays.entrySet()) {
            Employee emp = entry.getKey();
            int days = entry.getValue();
            int contractHours = emp.getHourlyRate() != null ? emp.getHourlyRate() : 8;
            System.out.println(String.format("üë§ %s (–¥–æ–≥–æ–≤–æ—Ä %d—á): %d —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏",
                    emp.getName(), contractHours, days));
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–Ω–∏
        int totalFirstShifts = 0, totalSecondShifts = 0, totalMiddleShifts = 0;
        for (DailySchedule daily : schedule.values()) {
            totalFirstShifts += daily.getFirstShiftCount();
            totalSecondShifts += daily.getSecondShiftCount();
            totalMiddleShifts += daily.getMiddleShiftCount();
        }

        System.out.println(String.format("\nüìà –û–±—â–æ —Å–º–µ–Ω–∏: %d –ø—ä—Ä–≤–∏, %d –≤—Ç–æ—Ä–∏, %d –º–µ–∂–¥–∏–Ω–Ω–∏",
                totalFirstShifts, totalSecondShifts, totalMiddleShifts));
        System.out.println("‚úÖ –ü–õ–ê–ù–ò–†–ê–ù–ï–¢–û –ó–ê–í–™–†–®–ò!\n");
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ò–∑—Ç—Ä–∏–≤–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ –¥–∞–¥–µ–Ω –º–µ—Å–µ—Ü
     */
    private void deleteAutoGeneratedShiftsForMonth(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> autoGeneratedEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() != null && event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        if (!autoGeneratedEvents.isEmpty()) {
            eventRepository.deleteAll(autoGeneratedEvents);
            System.out.println(String.format("üóëÔ∏è  –ò–∑—Ç—Ä–∏—Ç–∏ %d —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏", autoGeneratedEvents.size()));
        }
    }

    // ============================================================================
    // –ü–û–ú–û–©–ù–ò –ö–õ–ê–°–û–í–ï –ó–ê –û–†–ì–ê–ù–ò–ó–ê–¶–ò–Ø –ù–ê –î–ê–ù–ù–ò–¢–ï
    // ============================================================================

    /**
     * –ö–õ–ê–°: –ê–Ω–∞–ª–∏–∑ –Ω–∞ –Ω—É–∂–¥–∏—Ç–µ –∑–∞ –ø–ª–∞–Ω–∏—Ä–∞–Ω–µ
     */
    public static class ScheduleAnalysis {
        private int totalEmployees;
        private int totalDays;
        private int employeeCapacity;
        private int minShiftsNeeded;
        private int optimalShiftsNeeded;
        private int existingShifts;

        // Getters –∏ setters
        public int getTotalEmployees() { return totalEmployees; }
        public void setTotalEmployees(int totalEmployees) { this.totalEmployees = totalEmployees; }

        public int getTotalDays() { return totalDays; }
        public void setTotalDays(int totalDays) { this.totalDays = totalDays; }

        public int getEmployeeCapacity() { return employeeCapacity; }
        public void setEmployeeCapacity(int employeeCapacity) { this.employeeCapacity = employeeCapacity; }

        public int getMinShiftsNeeded() { return minShiftsNeeded; }
        public void setMinShiftsNeeded(int minShiftsNeeded) { this.minShiftsNeeded = minShiftsNeeded; }

        public int getOptimalShiftsNeeded() { return optimalShiftsNeeded; }
        public void setOptimalShiftsNeeded(int optimalShiftsNeeded) { this.optimalShiftsNeeded = optimalShiftsNeeded; }

        public int getExistingShifts() { return existingShifts; }
        public void setExistingShifts(int existingShifts) { this.existingShifts = existingShifts; }

        public int getDaysToSchedule() { return totalDays; }
        public int getTotalHoursNeeded() { return optimalShiftsNeeded * 8; }
    }

    /**
     * –ö–õ–ê–°: –ì—Ä–∞—Ñ–∏–∫ –∑–∞ –µ–¥–∏–Ω –¥–µ–Ω
     */
    public static class DailySchedule {
        private LocalDate date;
        private Map<Employee, ShiftType> existingShifts = new HashMap<>();
        private Map<Employee, ShiftType> generatedShifts = new HashMap<>();

        public DailySchedule(LocalDate date) {
            this.date = date;
        }

        public void addExistingShift(Employee employee, ShiftType shiftType) {
            existingShifts.put(employee, shiftType);
        }

        public void addGeneratedShift(Employee employee, ShiftType shiftType) {
            generatedShifts.put(employee, shiftType);
        }

        public boolean isEmployeeAlreadyScheduled(Employee employee) {
            return existingShifts.containsKey(employee) || generatedShifts.containsKey(employee);
        }

        public Set<Employee> getAllAssignedEmployees() {
            Set<Employee> all = new HashSet<>(existingShifts.keySet());
            all.addAll(generatedShifts.keySet());
            return all;
        }

        public int getFirstShiftCount() {
            return countShiftsOfType(ShiftType.FIRST);
        }

        public int getSecondShiftCount() {
            return countShiftsOfType(ShiftType.SECOND);
        }

        public int getMiddleShiftCount() {
            return countShiftsOfType(ShiftType.MIDDLE);
        }

        public int getTotalShiftCount() {
            return existingShifts.size() + generatedShifts.size();
        }

        private int countShiftsOfType(ShiftType type) {
            int count = 0;
            count += (int) existingShifts.values().stream().filter(t -> t == type).count();
            count += (int) generatedShifts.values().stream().filter(t -> t == type).count();
            return count;
        }

        // Getters
        public LocalDate getDate() { return date; }
        public Map<Employee, ShiftType> getExistingShifts() { return existingShifts; }
        public Map<Employee, ShiftType> getGeneratedShifts() { return generatedShifts; }
    }
}
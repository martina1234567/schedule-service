package com.example.schedule.service;

import com.example.schedule.entity.Employee;
import com.example.schedule.entity.Event;
import com.example.schedule.repository.EmployeeRepository;
import com.example.schedule.repository.EventRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.DayOfWeek;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ScheduleGeneratorService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private EventRepository eventRepository;

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∑–∞ —Å–º–µ–Ω–∏—Ç–µ
    private static final LocalTime FIRST_SHIFT_START = LocalTime.of(6, 0);
    private static final LocalTime FIRST_SHIFT_END = LocalTime.of(14, 30);

    private static final LocalTime SECOND_SHIFT_START = LocalTime.of(13, 30);
    private static final LocalTime SECOND_SHIFT_END = LocalTime.of(22, 0);

    private static final LocalTime MIDDLE_SHIFT_START = LocalTime.of(9, 30);
    private static final LocalTime MIDDLE_SHIFT_END = LocalTime.of(18, 0);

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∑–∞ –ø—Ä–∞–≤–∏–ª–∞—Ç–∞
    private static final int MIN_REST_HOURS = 12;

    // –ï–Ω—É–º –∑–∞ —Ç–∏–ø–æ–≤–µ—Ç–µ —Å–º–µ–Ω–∏
    public enum ShiftType {
        FIRST("First Shift", FIRST_SHIFT_START, FIRST_SHIFT_END, 8.5),
        SECOND("Second Shift", SECOND_SHIFT_START, SECOND_SHIFT_END, 8.5),
        MIDDLE("Middle Shift", MIDDLE_SHIFT_START, MIDDLE_SHIFT_END, 8.5);

        private final String name;
        private final LocalTime startTime;
        private final LocalTime endTime;
        private final double hours;

        ShiftType(String name, LocalTime startTime, LocalTime endTime, double hours) {
            this.name = name;
            this.startTime = startTime;
            this.endTime = endTime;
            this.hours = hours;
        }

        public String getName() { return name; }
        public LocalTime getStartTime() { return startTime; }
        public LocalTime getEndTime() { return endTime; }
        public double getHours() { return hours; }
    }

    /**
     * –ì–õ–ê–í–ù–ê –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥—Ä–∞—Ñ–∏–∫ –∑–∞ –º–µ—Å–µ—Ü–∞
     * –û–ë–ù–û–í–ï–ù–ê –° 12-–ß–ê–°–û–í–û –ü–†–ê–í–ò–õ–û –ò –¢–û–ß–ù–ò –ß–ê–°–û–í–ï –ü–û –î–û–ì–û–í–û–†
     */
    @Transactional
    public int generateMonthlySchedule(int year, int month) {
        System.out.println("üöÄ === –ó–ê–ü–û–ß–í–ê –ò–ù–¢–ï–õ–ò–ì–ï–ù–¢–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù–ï –ù–ê –ì–†–ê–§–ò–ö ===");
        System.out.println(String.format("üìÖ –ü–µ—Ä–∏–æ–¥: %02d/%d", month, year));

        // –°–¢–™–ü–ö–ê 1: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        List<Employee> allEmployees = employeeRepository.findAll();
        if (allEmployees.isEmpty()) {
            System.out.println("‚ùå –ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∑–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫");
            return 0;
        }

        deleteAutoGeneratedShiftsForMonth(year, month);
        List<LocalDate> allDaysInMonth = generateAllDaysForMonth(year, month);
        Map<LocalDate, List<Event>> existingManualShifts = getExistingManualShiftsByDate(year, month);

        System.out.println(String.format("üë• –°–ª—É–∂–∏—Ç–µ–ª–∏: %d, üìÖ –î–Ω–∏: %d, üìå –†—ä—á–Ω–∏ —Å–º–µ–Ω–∏: %d",
                allEmployees.size(), allDaysInMonth.size(),
                existingManualShifts.values().stream().mapToInt(List::size).sum()));

        // –°–¢–™–ü–ö–ê 2: –°—ä–∑–¥–∞–≤–∞–º–µ –∏–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–µ–Ω –ø–ª–∞–Ω–∏—Ä–æ–≤—á–∏–∫
        IntelligentScheduler scheduler = new IntelligentScheduler(allEmployees, allDaysInMonth, existingManualShifts);

        // –°–¢–™–ü–ö–ê 3: –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –≥—Ä–∞—Ñ–∏–∫
        Map<LocalDate, DailySchedule> monthlySchedule = scheduler.generateOptimalSchedule();

        // –°–¢–™–ü–ö–ê 4: –°—ä–∑–¥–∞–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å—ä–±–∏—Ç–∏—è—Ç–∞
        List<Event> generatedShifts = createEventsFromSchedule(monthlySchedule);
        eventRepository.saveAll(generatedShifts);

        // –°–¢–™–ü–ö–ê 5: –õ–æ–≥–≤–∞–º–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
        scheduler.logFinalResults();

        System.out.println(String.format("üéØ –ì–ï–ù–ï–†–ò–†–ê–ù–ï–¢–û –ó–ê–í–™–†–®–ò –£–°–ü–ï–®–ù–û! –û–±—â–æ —Å–º–µ–Ω–∏: %d", generatedShifts.size()));
        return generatedShifts.size();
    }

    /**
     * –ò–ù–¢–ï–õ–ò–ì–ï–ù–¢–ï–ù –ü–õ–ê–ù–ò–†–û–í–ß–ò–ö - –ì–ª–∞–≤–Ω–∏—è—Ç –∫–ª–∞—Å –∑–∞ –ª–æ–≥–∏–∫–∞—Ç–∞
     */
    public class IntelligentScheduler {
        private List<Employee> employees;
        private List<LocalDate> allDays;
        private Map<LocalDate, List<Event>> existingShifts;
        private Map<Employee, EmployeeState> employeeStates;
        private Map<LocalDate, DailySchedule> schedule;

        public IntelligentScheduler(List<Employee> employees, List<LocalDate> allDays,
                                    Map<LocalDate, List<Event>> existingShifts) {
            this.employees = employees;
            this.allDays = allDays;
            this.existingShifts = existingShifts;
            this.schedule = new LinkedHashMap<>();
            this.employeeStates = new HashMap<>();

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–µ–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª
            for (Employee emp : employees) {
                employeeStates.put(emp, new EmployeeState(emp));
            }
        }

        /**
         * –ì–õ–ê–í–ï–ù –ú–ï–¢–û–î: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –≥—Ä–∞—Ñ–∏–∫
         */
        public Map<LocalDate, DailySchedule> generateOptimalSchedule() {
            System.out.println("üß† –°—Ç–∞—Ä—Ç–∏—Ä–∞ –∏–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–µ–Ω –ø–ª–∞–Ω–∏—Ä–æ–≤—á–∏–∫...");

            // –°–¢–™–ü–ö–ê 1: –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏—Ç–µ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏
            processExistingShifts();

            // –°–¢–™–ü–ö–ê 2: –ü–ª–∞–Ω–∏—Ä–∞–º–µ –¥–µ–Ω –ø–æ –¥–µ–Ω —Å –∏–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–Ω–∞ –ª–æ–≥–∏–∫–∞
            for (LocalDate day : allDays) {
                DailySchedule dailySchedule = planDayIntelligently(day);
                schedule.put(day, dailySchedule);
                updateEmployeeStatesAfterDay(day, dailySchedule);
            }

            // –°–¢–™–ü–ö–ê 3: –ö–æ—Ä–∏–≥–∏—Ä–∞–º–µ –∑–∞ –º–∏–Ω–∏–º–∞–ª–Ω–∏—Ç–µ —á–∞—Å–æ–≤–µ –ø–æ –¥–æ–≥–æ–≤–æ—Ä
            ensureContractHoursAreMet();

            return schedule;
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –û–±—Ä–∞–±–æ—Ç–≤–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏—Ç–µ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏
         */
        private void processExistingShifts() {
            for (Map.Entry<LocalDate, List<Event>> entry : existingShifts.entrySet()) {
                LocalDate date = entry.getKey();
                for (Event event : entry.getValue()) {
                    Employee emp = event.getEmployee();
                    ShiftType shiftType = determineShiftType(event);

                    // –û–±–Ω–æ–≤—è–≤–∞–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª—è
                    EmployeeState state = employeeStates.get(emp);
                    if (state != null) {
                        state.addWorkedHours(shiftType.getHours());
                        state.setLastShift(date, shiftType);
                    }
                }
            }
        }

        /**
         * –ö–õ–Æ–ß–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ü–ª–∞–Ω–∏—Ä–∞ –µ–¥–∏–Ω –¥–µ–Ω –∏–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–Ω–æ
         */
        private DailySchedule planDayIntelligently(LocalDate day) {
            DailySchedule dailySchedule = new DailySchedule(day);

            // –°–¢–™–ü–ö–ê 1: –î–æ–±–∞–≤—è–º–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏—Ç–µ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏
            List<Event> existingForDay = existingShifts.get(day);
            if (existingForDay != null) {
                for (Event event : existingForDay) {
                    ShiftType type = determineShiftType(event);
                    dailySchedule.addExistingShift(event.getEmployee(), type);
                }
            }

            // –°–¢–™–ü–ö–ê 2: –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∫–æ–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ —Å–∞ –Ω–∞–ª–∏—á–Ω–∏ –∑–∞ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
            Map<ShiftType, List<Employee>> availableByShift = getAvailableEmployeesByShift(day, dailySchedule);

            // –°–¢–™–ü–ö–ê 3: –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –∫–æ–ª–∫–æ —Å–º–µ–Ω–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –¥–æ–±–∞–≤–∏–º
            int targetEmployeesPerDay = Math.max(3, employees.size() / 4); // –ü–æ–Ω–µ 3, –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ 1/4 –æ—Ç –≤—Å–∏—á–∫–∏

            int neededFirst = Math.max(1, targetEmployeesPerDay / 3) - dailySchedule.getFirstShiftCount();
            int neededSecond = Math.max(1, targetEmployeesPerDay / 3) - dailySchedule.getSecondShiftCount();
            int neededMiddle = Math.max(1, 1) - dailySchedule.getMiddleShiftCount();

            // –°–¢–™–ü–ö–ê 4: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä–∞–Ω–æ
            assignShiftsIntelligently(dailySchedule, availableByShift, neededFirst, neededSecond, neededMiddle);

            System.out.println(String.format("üìÖ %s (%s): %d–ø—ä—Ä–≤–∏ + %d–≤—Ç–æ—Ä–∏ + %d–º–µ–∂–¥–∏–Ω–Ω–∏ = %d –æ–±—â–æ",
                    day, day.getDayOfWeek().toString().substring(0,3),
                    dailySchedule.getFirstShiftCount(), dailySchedule.getSecondShiftCount(),
                    dailySchedule.getMiddleShiftCount(), dailySchedule.getTotalShiftCount()));

            return dailySchedule;
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –û–ø—Ä–µ–¥–µ–ª—è –∫–æ–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ —Å–∞ –Ω–∞–ª–∏—á–Ω–∏ –∑–∞ –≤—Å—è–∫–∞ —Å–º—è–Ω–∞
         */
        private Map<ShiftType, List<Employee>> getAvailableEmployeesByShift(LocalDate day, DailySchedule dailySchedule) {
            Map<ShiftType, List<Employee>> available = new HashMap<>();

            for (ShiftType shiftType : ShiftType.values()) {
                List<Employee> availableForShift = new ArrayList<>();

                for (Employee emp : employees) {
                    // –ü—Ä–µ—Å–∫–∞—á–∞–º–µ –∞–∫–æ —Å–ª—É–∂–∏—Ç–µ–ª—è—Ç –≤–µ—á–µ —Ä–∞–±–æ—Ç–∏ –¥–Ω–µ—Å
                    if (dailySchedule.isEmployeeAlreadyScheduled(emp)) {
                        continue;
                    }

                    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ
                    if (canEmployeeWorkShift(emp, day, shiftType)) {
                        availableForShift.add(emp);
                    }
                }

                // –°–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (—Å–ª—É–∂–∏—Ç–µ–ª–∏ –∫–æ–∏—Ç–æ —Å–µ –Ω—É–∂–¥–∞—è—Ç –æ—Ç –ø–æ–≤–µ—á–µ —á–∞—Å–æ–≤–µ –ø—ä—Ä–≤–æ)
                availableForShift.sort((emp1, emp2) -> {
                    EmployeeState state1 = employeeStates.get(emp1);
                    EmployeeState state2 = employeeStates.get(emp2);

                    double need1 = state1.getMonthlyTargetHours() - state1.getWorkedHours();
                    double need2 = state2.getMonthlyTargetHours() - state2.getWorkedHours();

                    return Double.compare(need2, need1); // –ù–∏—Å—Ö–æ–¥—è—â —Ä–µ–¥ - –Ω–∞–π-–Ω—É–∂–¥–∞–µ—â–∏ —Å–µ –ø—ä—Ä–≤–æ
                });

                available.put(shiftType, availableForShift);
            }

            return available;
        }

        /**
         * –ö–†–ò–¢–ò–ß–ù–ê –§–£–ù–ö–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–≤–∞ 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ
         */
        private boolean canEmployeeWorkShift(Employee emp, LocalDate day, ShiftType shiftType) {
            EmployeeState state = employeeStates.get(emp);
            if (state == null || state.getLastShiftDate() == null) {
                return true; // –ù–æ–≤ —Å–ª—É–∂–∏—Ç–µ–ª –∏–ª–∏ –ø—ä—Ä–≤–∞ —Å–º—è–Ω–∞
            }

            // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ —Å–∞–º–æ –∞–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ —Å–º—è–Ω–∞ –µ –±–∏–ª–∞ –≤—á–µ—Ä–∞
            LocalDate previousDay = day.minusDays(1);
            if (!previousDay.equals(state.getLastShiftDate())) {
                return true; // –ù–µ –µ —Ä–∞–±–æ—Ç–∏–ª –≤—á–µ—Ä–∞
            }

            ShiftType lastShift = state.getLastShiftType();
            if (lastShift == null) {
                return true;
            }

            // –ü–†–ê–í–ò–õ–ê–¢–ê –ó–ê 12-–ß–ê–°–û–í–ê –ü–û–ß–ò–í–ö–ê:
            switch (lastShift) {
                case SECOND: // –í—Ç–æ—Ä–∞ —Å–º—è–Ω–∞ –¥–æ 22:00 -> –Ω–∞–π-—Ä–∞–Ω–æ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞ –Ω–∞ 13:30 —Å–ª–µ–¥–≤–∞—â–∏—è –¥–µ–Ω
                    return shiftType == ShiftType.SECOND; // –°–∞–º–æ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞ –µ –ø–æ–∑–≤–æ–ª–µ–Ω–∞

                case MIDDLE: // –ú–µ–∂–¥–∏–Ω–Ω–∞ —Å–º—è–Ω–∞ –¥–æ 18:00 -> –Ω–∞–π-—Ä–∞–Ω–æ –ø—ä—Ä–≤–∞ —Å–º—è–Ω–∞ –Ω–∞ 06:00 —Å–ª–µ–¥–≤–∞—â–∏—è –¥–µ–Ω
                    return shiftType == ShiftType.FIRST || shiftType == ShiftType.MIDDLE || shiftType == ShiftType.SECOND;

                case FIRST: // –ü—ä—Ä–≤–∞ —Å–º—è–Ω–∞ –¥–æ 14:30 -> –Ω–∞–π-—Ä–∞–Ω–æ –ø—ä—Ä–≤–∞ —Å–º—è–Ω–∞ –Ω–∞ 06:00 —Å–ª–µ–¥–≤–∞—â–∏—è –¥–µ–Ω
                    return shiftType == ShiftType.FIRST || shiftType == ShiftType.MIDDLE || shiftType == ShiftType.SECOND;

                default:
                    return true;
            }
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è —Å–º–µ–Ω–∏—Ç–µ –∏–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–Ω–æ
         */
        private void assignShiftsIntelligently(DailySchedule dailySchedule,
                                               Map<ShiftType, List<Employee>> availableByShift,
                                               int neededFirst, int neededSecond, int neededMiddle) {

            // –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ú–µ–∂–¥–∏–Ω–Ω–∏ —Å–º–µ–Ω–∏ (–≤–∏–Ω–∞–≥–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–º–∞ –ø–æ–Ω–µ 1)
            assignShiftsOfType(dailySchedule, availableByShift.get(ShiftType.MIDDLE), ShiftType.MIDDLE, neededMiddle);

            // –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ë–∞–ª–∞–Ω—Å–∏—Ä–∞–º–µ –ø—ä—Ä–≤–∞ –∏ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞
            while ((neededFirst > 0 || neededSecond > 0)) {
                boolean assignedAny = false;

                // –ê–∫–æ —Ç—Ä—è–±–≤–∞—Ç –∏ –¥–≤–µ—Ç–µ, –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä–∞–º–µ —Å–ø–æ—Ä–µ–¥ –Ω—É–∂–¥–∞—Ç–∞
                if (neededFirst > 0 && !availableByShift.get(ShiftType.FIRST).isEmpty()) {
                    Employee emp = availableByShift.get(ShiftType.FIRST).remove(0);
                    dailySchedule.addGeneratedShift(emp, ShiftType.FIRST);
                    neededFirst--;
                    assignedAny = true;
                }

                if (neededSecond > 0 && !availableByShift.get(ShiftType.SECOND).isEmpty()) {
                    Employee emp = availableByShift.get(ShiftType.SECOND).remove(0);
                    dailySchedule.addGeneratedShift(emp, ShiftType.SECOND);
                    neededSecond--;
                    assignedAny = true;
                }

                if (!assignedAny) {
                    break; // –ù—è–º–∞ –ø–æ–≤–µ—á–µ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏
                }
            }
        }

        /**
         * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è —Å–º–µ–Ω–∏ –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω —Ç–∏–ø
         */
        private void assignShiftsOfType(DailySchedule dailySchedule, List<Employee> available,
                                        ShiftType shiftType, int needed) {
            int assigned = 0;
            for (Employee emp : available) {
                if (assigned >= needed) break;

                dailySchedule.addGeneratedShift(emp, shiftType);
                assigned++;
            }
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –û–±–Ω–æ–≤—è–≤–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ —Å–ª–µ–¥ –¥–µ–Ω
         */
        private void updateEmployeeStatesAfterDay(LocalDate day, DailySchedule dailySchedule) {
            // –û–±–Ω–æ–≤—è–≤–∞–º–µ –∑–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—Ç–µ —Å–º–µ–Ω–∏
            for (Map.Entry<Employee, ShiftType> entry : dailySchedule.getGeneratedShifts().entrySet()) {
                Employee emp = entry.getKey();
                ShiftType shiftType = entry.getValue();

                EmployeeState state = employeeStates.get(emp);
                if (state != null) {
                    state.addWorkedHours(shiftType.getHours());
                    state.setLastShift(day, shiftType);
                }
            }
        }

        /**
         * –ö–†–ò–¢–ò–ß–ù–ê –§–£–ù–ö–¶–ò–Ø: –ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞ –º–∏–Ω–∏–º–∞–ª–Ω–∏—Ç–µ —á–∞—Å–æ–≤–µ –ø–æ –¥–æ–≥–æ–≤–æ—Ä
         */
        private void ensureContractHoursAreMet() {
            System.out.println("üîç –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ —Å–∞ —Å–ø–∞–∑–µ–Ω–∏ –¥–æ–≥–æ–≤–æ—Ä–Ω–∏—Ç–µ —á–∞—Å–æ–≤–µ...");

            for (Employee emp : employees) {
                EmployeeState state = employeeStates.get(emp);
                double target = state.getMonthlyTargetHours();
                double worked = state.getWorkedHours();
                double shortage = target - worked;

                if (shortage > 0.1) { // –ú–∞–ª–∫–∞ —Ç–æ–ª–µ—Ä–∞–Ω—Å –∑–∞ floating point –≥—Ä–µ—à–∫–∏
                    System.out.println(String.format("‚ö†Ô∏è %s –∏–º–∞ –¥–µ—Ñ–∏—Ü–∏—Ç –æ—Ç %.1f—á (—Ä–∞–±–æ—Ç–∏–ª %.1f/%.1f)",
                            emp.getName(), shortage, worked, target));

                    // –û–ø–∏—Ç–≤–∞–º–µ —Å–µ –¥–∞ –¥–æ–±–∞–≤–∏–º –æ—â–µ —Å–º–µ–Ω–∏
                    addAdditionalShiftsForEmployee(emp, shortage);
                }
            }
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –î–æ–±–∞–≤—è –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ —Å–ª—É–∂–∏—Ç–µ–ª —Å –¥–µ—Ñ–∏—Ü–∏—Ç
         */
        private void addAdditionalShiftsForEmployee(Employee emp, double neededHours) {
            int shiftsToAdd = (int) Math.ceil(neededHours / 8.5);
            int added = 0;

            // –¢—ä—Ä—Å–∏–º –¥–Ω–∏ –∫—ä–¥–µ—Ç–æ —Å–ª—É–∂–∏—Ç–µ–ª—è—Ç –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏
            for (LocalDate day : allDays) {
                if (added >= shiftsToAdd) break;

                DailySchedule dailySchedule = schedule.get(day);
                if (dailySchedule.isEmployeeAlreadyScheduled(emp)) {
                    continue; // –í–µ—á–µ —Ä–∞–±–æ—Ç–∏ —Ç–æ–∑–∏ –¥–µ–Ω
                }

                // –û–ø–∏—Ç–≤–∞–º–µ —Å–µ —Å —Ä–∞–∑–ª–∏—á–Ω–∏—Ç–µ —Å–º–µ–Ω–∏
                for (ShiftType shiftType : ShiftType.values()) {
                    if (canEmployeeWorkShift(emp, day, shiftType)) {
                        dailySchedule.addGeneratedShift(emp, shiftType);
                        employeeStates.get(emp).addWorkedHours(shiftType.getHours());
                        employeeStates.get(emp).setLastShift(day, shiftType);
                        added++;

                        System.out.println(String.format("‚ûï –î–æ–±–∞–≤–µ–Ω–∞ —Å–º—è–Ω–∞ –∑–∞ %s –Ω–∞ %s (%s)",
                                emp.getName(), day, shiftType.getName()));
                        break;
                    }
                }
            }

            if (added < shiftsToAdd) {
                System.out.println(String.format("‚ö†Ô∏è –ù–µ –º–æ–∂–µ –¥–∞ —Å–µ –¥–æ–±–∞–≤—è—Ç –≤—Å–∏—á–∫–∏ –Ω—É–∂–Ω–∏ —Å–º–µ–Ω–∏ –∑–∞ %s (–¥–æ–±–∞–≤–µ–Ω–∏ %d/%d)",
                        emp.getName(), added, shiftsToAdd));
            }
        }

        /**
         * –§–£–ù–ö–¶–ò–Ø: –õ–æ–≥–≤–∞ —Ñ–∏–Ω–∞–ª–Ω–∏—Ç–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏
         */
        public void logFinalResults() {
            System.out.println("\nüìä === –§–ò–ù–ê–õ–ù–ò –†–ï–ó–£–õ–¢–ê–¢–ò ===");

            for (Employee emp : employees) {
                EmployeeState state = employeeStates.get(emp);
                int contractHours = emp.getHourlyRate() != null ? emp.getHourlyRate() : 8;

                System.out.println(String.format("üë§ %s (–¥–æ–≥–æ–≤–æ—Ä %d—á): %.1f/%.1f —á–∞—Å–∞ (%.1f%% –æ—Ç —Ü–µ–ª—Ç–∞)",
                        emp.getName(), contractHours, state.getWorkedHours(), state.getMonthlyTargetHours(),
                        (state.getWorkedHours() / state.getMonthlyTargetHours()) * 100));
            }

            // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–Ω–∏
            int totalShifts = schedule.values().stream().mapToInt(DailySchedule::getTotalShiftCount).sum();
            System.out.println(String.format("\nüìà –û–±—â–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏: %d", totalShifts));
        }
    }

    /**
     * –ö–õ–ê–°: –°—ä—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª
     */
    public static class EmployeeState {
        private Employee employee;
        private double workedHours;
        private double monthlyTargetHours;
        private LocalDate lastShiftDate;
        private ShiftType lastShiftType;

        public EmployeeState(Employee employee) {
            this.employee = employee;
            this.workedHours = 0.0;

            // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –º–µ—Å–µ—á–Ω–∞—Ç–∞ —Ü–µ–ª –Ω–∞ –±–∞–∑–∞ –¥–æ–≥–æ–≤–æ—Ä–∞ (4 —Å–µ–¥–º–∏—Ü–∏ –≤ –º–µ—Å–µ—Ü)
            int contractHours = employee.getHourlyRate() != null ? employee.getHourlyRate() : 8;
            this.monthlyTargetHours = (contractHours * 7.0 * 4.33); // 4.33 —Å–µ–¥–º–∏—Ü–∏ –≤ –º–µ—Å–µ—Ü —Å—Ä–µ–¥–Ω–æ
        }

        public void addWorkedHours(double hours) {
            this.workedHours += hours;
        }

        public void setLastShift(LocalDate date, ShiftType shiftType) {
            this.lastShiftDate = date;
            this.lastShiftType = shiftType;
        }

        // Getters
        public Employee getEmployee() { return employee; }
        public double getWorkedHours() { return workedHours; }
        public double getMonthlyTargetHours() { return monthlyTargetHours; }
        public LocalDate getLastShiftDate() { return lastShiftDate; }
        public ShiftType getLastShiftType() { return lastShiftType; }
    }

    // ============================================================================
    // –ü–û–ú–û–©–ù–ò –§–£–ù–ö–¶–ò–ò (–æ—Ç –ø—Ä–µ–¥–∏—à–Ω–∞—Ç–∞ –≤–µ—Ä—Å–∏—è)
    // ============================================================================

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –¥–Ω–∏ –≤ –º–µ—Å–µ—Ü–∞
     */
    private List<LocalDate> generateAllDaysForMonth(int year, int month) {
        List<LocalDate> allDays = new ArrayList<>();
        LocalDate date = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());

        while (!date.isAfter(endOfMonth)) {
            allDays.add(date);
            date = date.plusDays(1);
        }

        return allDays;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–∞–≤–∞ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏ –≥—Ä—É–ø–∏—Ä–∞–Ω–∏ –ø–æ –¥–∞—Ç–∏
     */
    private Map<LocalDate, List<Event>> getExistingManualShiftsByDate(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> manualEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() == null || !event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .filter(event -> event.getLeaveType() == null)
                .collect(Collectors.toList());

        return manualEvents.stream()
                .collect(Collectors.groupingBy(event -> event.getStart().toLocalDate()));
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –û–ø—Ä–µ–¥–µ–ª—è —Ç–∏–ø–∞ —Å–º—è–Ω–∞
     */
    private ShiftType determineShiftType(Event event) {
        LocalTime startTime = event.getStart().toLocalTime();

        if (startTime.equals(FIRST_SHIFT_START)) return ShiftType.FIRST;
        if (startTime.equals(SECOND_SHIFT_START)) return ShiftType.SECOND;
        if (startTime.equals(MIDDLE_SHIFT_START)) return ShiftType.MIDDLE;

        // Fallback –ª–æ–≥–∏–∫–∞
        if (startTime.isBefore(LocalTime.of(10, 0))) return ShiftType.FIRST;
        if (startTime.isAfter(LocalTime.of(13, 0))) return ShiftType.SECOND;
        return ShiftType.MIDDLE;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –°—ä–∑–¥–∞–≤–∞ Event –æ–±–µ–∫—Ç–∏ –æ—Ç –ø–ª–∞–Ω–∏—Ä–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫
     */
    private List<Event> createEventsFromSchedule(Map<LocalDate, DailySchedule> schedule) {
        List<Event> events = new ArrayList<>();

        for (Map.Entry<LocalDate, DailySchedule> entry : schedule.entrySet()) {
            LocalDate date = entry.getKey();
            DailySchedule daily = entry.getValue();

            for (Map.Entry<Employee, ShiftType> shiftEntry : daily.getGeneratedShifts().entrySet()) {
                Employee emp = shiftEntry.getKey();
                ShiftType shiftType = shiftEntry.getValue();

                Event event = new Event();
                event.setTitle(emp.getName().split(" ")[0]);
                event.setStart(date.atTime(shiftType.getStartTime()));
                event.setEnd(date.atTime(shiftType.getEndTime()));
                event.setActivity("Auto-generated " + shiftType.getName());
                event.setEmployee(emp);
                event.setIsAutoGenerated(true);

                events.add(event);
            }
        }

        return events;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ò–∑—Ç—Ä–∏–≤–∞ —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏
     */
    private void deleteAutoGeneratedShiftsForMonth(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> autoGeneratedEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() != null && event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        if (!autoGeneratedEvents.isEmpty()) {
            eventRepository.deleteAll(autoGeneratedEvents);
            System.out.println(String.format("üóëÔ∏è –ò–∑—Ç—Ä–∏—Ç–∏ %d —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏", autoGeneratedEvents.size()));
        }
    }

    // ============================================================================
    // –ö–õ–ê–°: –î–ù–ï–í–ï–ù –ì–†–ê–§–ò–ö (–æ—Ç –ø—Ä–µ–¥–∏—à–Ω–∞—Ç–∞ –≤–µ—Ä—Å–∏—è)
    // ============================================================================

    public static class DailySchedule {
        private LocalDate date;
        private Map<Employee, ShiftType> existingShifts = new HashMap<>();
        private Map<Employee, ShiftType> generatedShifts = new HashMap<>();

        public DailySchedule(LocalDate date) {
            this.date = date;
        }

        public void addExistingShift(Employee employee, ShiftType shiftType) {
            existingShifts.put(employee, shiftType);
        }

        public void addGeneratedShift(Employee employee, ShiftType shiftType) {
            generatedShifts.put(employee, shiftType);
        }

        public boolean isEmployeeAlreadyScheduled(Employee employee) {
            return existingShifts.containsKey(employee) || generatedShifts.containsKey(employee);
        }

        public Set<Employee> getAllAssignedEmployees() {
            Set<Employee> all = new HashSet<>(existingShifts.keySet());
            all.addAll(generatedShifts.keySet());
            return all;
        }

        public int getFirstShiftCount() {
            return countShiftsOfType(ShiftType.FIRST);
        }

        public int getSecondShiftCount() {
            return countShiftsOfType(ShiftType.SECOND);
        }

        public int getMiddleShiftCount() {
            return countShiftsOfType(ShiftType.MIDDLE);
        }

        public int getTotalShiftCount() {
            return existingShifts.size() + generatedShifts.size();
        }

        private int countShiftsOfType(ShiftType type) {
            int count = 0;
            count += (int) existingShifts.values().stream().filter(t -> t == type).count();
            count += (int) generatedShifts.values().stream().filter(t -> t == type).count();
            return count;
        }

        // Getters
        public LocalDate getDate() { return date; }
        public Map<Employee, ShiftType> getExistingShifts() { return existingShifts; }
        public Map<Employee, ShiftType> getGeneratedShifts() { return generatedShifts; }
    }
}
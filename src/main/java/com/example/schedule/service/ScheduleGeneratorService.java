package com.example.schedule.service;

import com.example.schedule.entity.Employee;
import com.example.schedule.entity.Event;
import com.example.schedule.repository.EmployeeRepository;
import com.example.schedule.repository.EventRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.DayOfWeek;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ScheduleGeneratorService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private EventRepository eventRepository;

    // –î–û–ë–ê–í–ò –¢–û–ó–ò –†–ï–î:
    @Autowired
    private WeeklyScheduleService weeklyScheduleService;

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∑–∞ —Å–º–µ–Ω–∏—Ç–µ
    private static final LocalTime FIRST_SHIFT_START = LocalTime.of(6, 0);
    private static final LocalTime FIRST_SHIFT_END = LocalTime.of(14, 30);

    private static final LocalTime SECOND_SHIFT_START = LocalTime.of(13, 30);
    private static final LocalTime SECOND_SHIFT_END = LocalTime.of(22, 0);

    private static final LocalTime MIDDLE_SHIFT_START = LocalTime.of(9, 30);
    private static final LocalTime MIDDLE_SHIFT_END = LocalTime.of(18, 0);

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∑–∞ –ø—Ä–∞–≤–∏–ª–∞—Ç–∞
    private static final double SHIFT_HOURS = 8.5; // –ß–∞—Å–æ–≤–µ –Ω–∞ —Å–º—è–Ω–∞
    private static final int MAX_CONSECUTIVE_DAYS = 6; // –ú–∞–∫—Å–∏–º—É–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ –¥–Ω–∏

    // –ï–Ω—É–º –∑–∞ —Ç–∏–ø–æ–≤–µ—Ç–µ —Å–º–µ–Ω–∏
    public enum ShiftType {
        FIRST("First Shift", FIRST_SHIFT_START, FIRST_SHIFT_END),
        SECOND("Second Shift", SECOND_SHIFT_START, SECOND_SHIFT_END),
        MIDDLE("Middle Shift", MIDDLE_SHIFT_START, MIDDLE_SHIFT_END);

        private final String name;
        private final LocalTime startTime;
        private final LocalTime endTime;

        ShiftType(String name, LocalTime startTime, LocalTime endTime) {
            this.name = name;
            this.startTime = startTime;
            this.endTime = endTime;
        }

        public String getName() { return name; }
        public LocalTime getStartTime() { return startTime; }
        public LocalTime getEndTime() { return endTime; }
    }

    /**
     * –ì–õ–ê–í–ù–ê –§–£–ù–ö–¶–ò–Ø: –ì–µ–Ω–µ—Ä–∏—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥—Ä–∞—Ñ–∏–∫ —Å—ä—Å –°–¢–†–û–ì–ò –ø—Ä–∞–≤–∏–ª–∞
     */
    @Transactional
    public int generateMonthlySchedule(int year, int month) {
        System.out.println("üöÄ === –ó–ê–ü–û–ß–í–ê –û–ü–†–û–°–¢–ï–ù–û –ì–ï–ù–ï–†–ò–†–ê–ù–ï –ù–ê –ì–†–ê–§–ò–ö ===");
        System.out.println(String.format("üìÖ –ü–µ—Ä–∏–æ–¥: %02d/%d", month, year));

        // –°–¢–™–ü–ö–ê 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞
        List<Employee> allEmployees = employeeRepository.findAll();
        if (allEmployees.isEmpty()) {
            System.out.println("‚ùå –ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏");
            return 0;
        }

        List<LocalDate> allDaysInMonth = generateAllDaysForMonth(year, month);
        Map<LocalDate, List<Event>> existingShifts = getExistingManualShiftsByDate(year, month);

        // –ò–∑—Ç—Ä–∏–≤–∞–º–µ —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏
        deleteAutoGeneratedShiftsForMonth(year, month);

        System.out.println(String.format("üë• –°–ª—É–∂–∏—Ç–µ–ª–∏: %d, üìÖ –î–Ω–∏: %d, üìå –†—ä—á–Ω–∏ —Å–º–µ–Ω–∏: %d",
                allEmployees.size(), allDaysInMonth.size(),
                existingShifts.values().stream().mapToInt(List::size).sum()));

        // –°–¢–™–ü–ö–ê 2: –°—ä–∑–¥–∞–≤–∞–º–µ –ø—Ä–æ—Å—Ç tracker
        SimpleScheduleTracker tracker = new SimpleScheduleTracker(allEmployees, allDaysInMonth);

        // –î–æ–±–∞–≤—è–º–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏—Ç–µ —Ä—ä—á–Ω–∏ —Å–º–µ–Ω–∏
        addExistingShiftsToTracker(tracker, existingShifts);

        // –°–¢–™–ü–ö–ê 3: –û—Å–Ω–æ–≤–Ω–æ –ø–ª–∞–Ω–∏—Ä–∞–Ω–µ - –¥–µ–Ω –ø–æ –¥–µ–Ω —Å—ä—Å —Å—Ç—Ä–æ–≥–∏ –ø—Ä–∞–≤–∏–ª–∞
        planBasicSchedule(tracker, allDaysInMonth);

        // –°–¢–™–ü–ö–ê 4: –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–æ–≥–æ–≤–æ—Ä–Ω–∏—Ç–µ —á–∞—Å–æ–≤–µ –∏ –¥–æ–±–∞–≤—è–º–µ —Å–º–µ–Ω–∏ –∞–∫–æ –µ –Ω—É–∂–Ω–æ
        ensureMinimumHours(tracker, allDaysInMonth);

        // –°–¢–™–ü–ö–ê 5: –°—ä–∑–¥–∞–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ Event –æ–±–µ–∫—Ç–∏—Ç–µ
        List<Event> generatedEvents = createEventsFromTracker(tracker);
        eventRepository.saveAll(generatedEvents);

        // –î–û–ë–ê–í–ò –¢–ï–ó–ò –†–ï–î–û–í–ï:
        // –°–¢–™–ü–ö–ê 5.5: –û–±–Ω–æ–≤—è–≤–∞–º–µ weekly_schedule —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –∑–∞ –≤—Å–∏—á–∫–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏
        System.out.println("üîÑ Updating weekly schedule data for all employees...");
        for (Employee employee : allEmployees) {
            try {
                weeklyScheduleService.getWeeklyScheduleForMonth(employee.getId(), year, month);
                System.out.println(String.format("‚úÖ Updated weekly schedule for %s", employee.getName()));
            } catch (Exception e) {
                System.err.println(String.format("‚ùå Failed to update weekly schedule for %s: %s",
                        employee.getName(), e.getMessage()));
            }
        }

// –°–¢–™–ü–ö–ê 6: –§–∏–Ω–∞–ª–Ω–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        logFinalResults(tracker, generatedEvents);

        System.out.println(String.format("üéØ –ì–ï–ù–ï–†–ò–†–ê–ù–ï–¢–û –ó–ê–í–™–†–®–ò! –°—ä–∑–¥–∞–¥–µ–Ω–∏ —Å–º–µ–Ω–∏: %d", generatedEvents.size()));
        return generatedEvents.size();
    }

    /**
     * –ï–¢–ê–ü 3: –û—Å–Ω–æ–≤–Ω–æ –ø–ª–∞–Ω–∏—Ä–∞–Ω–µ –¥–µ–Ω –ø–æ –¥–µ–Ω —Å—ä—Å —Å—Ç—Ä–æ–≥–∏ –ø—Ä–∞–≤–∏–ª–∞
     */
    private void planBasicSchedule(SimpleScheduleTracker tracker, List<LocalDate> allDays) {
        System.out.println("üìÖ === –û–°–ù–û–í–ù–û –ü–õ–ê–ù–ò–†–ê–ù–ï (1 –°–ú–Ø–ù–ê –ù–ê –î–ï–ù MAX) ===");

        // –°—ä–∑–¥–∞–≤–∞–º–µ —Ä–æ—Ç–∞—Ü–∏–æ–Ω–Ω–∏ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏
        assignRotationalRestDays(tracker, allDays);

        // –ü–ª–∞–Ω–∏—Ä–∞–º–µ –¥–µ–Ω –ø–æ –¥–µ–Ω
        for (LocalDate day : allDays) {
            planSingleDay(tracker, day);
        }
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –°—ä–∑–¥–∞–≤–∞ —Ä–æ—Ç–∞—Ü–∏–æ–Ω–Ω–∏ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏ –°–ü–û–†–ï–î –î–û–ì–û–í–û–†–ê
     */
    private void assignRotationalRestDays(SimpleScheduleTracker tracker, List<LocalDate> allDays) {
        System.out.println("üîÑ –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏ —Å–ø–æ—Ä–µ–¥ –¥–æ–≥–æ–≤–æ—Ä–∞...");

        List<Employee> employees = tracker.getAllEmployees();

        for (int i = 0; i < employees.size(); i++) {
            Employee emp = employees.get(i);
            int contractHours = getContractHours(emp);

            // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –∫–æ–ª–∫–æ –¥–Ω–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ —Ä–∞–±–æ—Ç–∏ —Å–ø–æ—Ä–µ–¥ –¥–æ–≥–æ–≤–æ—Ä–∞
            double monthlyHours = calculateRequiredMonthlyHours(emp);
            int maxWorkDaysPerMonth = (int) Math.ceil(monthlyHours / SHIFT_HOURS);
            int restDaysNeeded = allDays.size() - maxWorkDaysPerMonth;

            System.out.println(String.format("üë§ %s (–¥–æ–≥–æ–≤–æ—Ä %d—á): –º–æ–∂–µ –º–∞–∫—Å %d —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏, —Ç—Ä—è–±–≤–∞ %d –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏",
                    emp.getName(), contractHours, maxWorkDaysPerMonth, restDaysNeeded));

            // –°—ä–∑–¥–∞–≤–∞–º–µ —Ä–æ—Ç–∞—Ü–∏–æ–Ω–µ–Ω —à–∞–±–ª–æ–Ω –∑–∞ –ø–æ—á–∏–≤–∫–∏ —Å–ø–æ—Ä–µ–¥ –¥–æ–≥–æ–≤–æ—Ä–∞
            assignRestDaysForEmployee(tracker, emp, allDays, restDaysNeeded, i);
        }
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –ó–∞–¥–∞–≤–∞ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏ –∑–∞ –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω —Å–ª—É–∂–∏—Ç–µ–ª
     */
    private void assignRestDaysForEmployee(SimpleScheduleTracker tracker, Employee emp,
                                           List<LocalDate> allDays, int restDaysNeeded, int employeeIndex) {

        // –†–∞–∑–ª–∏—á–Ω–∏ –±–∞–∑–æ–≤–∏ —à–∞–±–ª–æ–Ω–∏ –∑–∞ —Ä–æ—Ç–∞—Ü–∏—è
        List<DayOfWeek> basePattern;
        switch (employeeIndex % 7) {
            case 0: basePattern = Arrays.asList(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY); break;
            case 1: basePattern = Arrays.asList(DayOfWeek.MONDAY, DayOfWeek.TUESDAY); break;
            case 2: basePattern = Arrays.asList(DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY); break;
            case 3: basePattern = Arrays.asList(DayOfWeek.FRIDAY, DayOfWeek.SATURDAY); break;
            case 4: basePattern = Arrays.asList(DayOfWeek.SUNDAY, DayOfWeek.MONDAY); break;
            case 5: basePattern = Arrays.asList(DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY); break;
            default: basePattern = Arrays.asList(DayOfWeek.THURSDAY, DayOfWeek.FRIDAY); break;
        }

        Set<LocalDate> restDays = new HashSet<>();

        // –ü—ä—Ä–≤–æ –¥–æ–±–∞–≤—è–º–µ –±–∞–∑–æ–≤–∏—è —à–∞–±–ª–æ–Ω (2 –¥–Ω–∏ —Å–µ–¥–º–∏—á–Ω–æ)
        for (LocalDate day : allDays) {
            if (basePattern.contains(day.getDayOfWeek())) {
                restDays.add(day);
            }
        }

        // –ê–∫–æ —Ç—Ä—è–±–≤–∞—Ç –ø–æ–≤–µ—á–µ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏ (–∑–∞ 4—á –∏ 6—á –¥–æ–≥–æ–≤–æ—Ä–∏), –¥–æ–±–∞–≤—è–º–µ –æ—â–µ
        if (restDays.size() < restDaysNeeded) {
            List<LocalDate> remainingDays = allDays.stream()
                    .filter(day -> !restDays.contains(day))
                    .collect(Collectors.toList());

            Collections.shuffle(remainingDays);

            int additionalDaysNeeded = restDaysNeeded - restDays.size();
            for (int i = 0; i < additionalDaysNeeded && i < remainingDays.size(); i++) {
                restDays.add(remainingDays.get(i));
            }
        }

        // –ó–∞–¥–∞–≤–∞–º–µ –ø–æ—á–∏–≤–Ω–∏—Ç–µ –¥–Ω–∏
        for (LocalDate restDay : restDays) {
            tracker.setRestDay(emp, restDay);
        }

        System.out.println(String.format("   üìÖ %s: %d –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏ –æ—Ç %d",
                emp.getName(), restDays.size(), allDays.size()));
    }

    /**
     * –ö–õ–Æ–ß–û–í–ê –§–£–ù–ö–¶–ò–Ø: –ü–ª–∞–Ω–∏—Ä–∞ –µ–¥–∏–Ω –¥–µ–Ω —Å—ä—Å –°–¢–†–û–ì–ò –ø—Ä–∞–≤–∏–ª–∞
     */
    private void planSingleDay(SimpleScheduleTracker tracker, LocalDate day) {
        // –°–¢–™–ü–ö–ê 1: –ù–∞–º–∏—Ä–∞–º–µ –∫–æ–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –º–æ–≥–∞—Ç –¥–∞ —Ä–∞–±–æ—Ç—è—Ç
        List<Employee> availableEmployees = new ArrayList<>();

        for (Employee emp : tracker.getAllEmployees()) {
            if (canEmployeeWorkOnDay(tracker, emp, day)) {
                availableEmployees.add(emp);
            }
        }

        if (availableEmployees.isEmpty()) {
            System.out.println(String.format("‚ö†Ô∏è %s: –ù—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Å–ª—É–∂–∏—Ç–µ–ª–∏!", day));
            return;
        }

        // –°–¢–™–ü–ö–ê 2: –†–∞–∑–±—ä—Ä–∫–≤–∞–º–µ –∑–∞ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç
        Collections.shuffle(availableEmployees);

        // –°–¢–™–ü–ö–ê 3: –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∫–æ–ª–∫–æ —Å–ª—É–∂–∏—Ç–µ–ª–∏ —Ç—Ä—è–±–≤–∞—Ç (3-6)
        int employeesNeeded = Math.max(3, Math.min(availableEmployees.size(), 6));

        // –°–¢–™–ü–ö–ê 4: –†–∞–∑–¥–µ–ª—è–º–µ —Å–ª—É–∂–∏—Ç–µ–ª–∏—Ç–µ –ø–æ —Å–º–µ–Ω–∏ –∫–æ–∏—Ç–æ –º–æ–≥–∞—Ç –¥–∞ —Ä–∞–±–æ—Ç—è—Ç
        List<Employee> canWorkFirst = filterByAllowedShift(tracker, availableEmployees, day, ShiftType.FIRST);
        List<Employee> canWorkSecond = filterByAllowedShift(tracker, availableEmployees, day, ShiftType.SECOND);
        List<Employee> canWorkMiddle = filterByAllowedShift(tracker, availableEmployees, day, ShiftType.MIDDLE);

        // –°–¢–™–ü–ö–ê 5: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–º–µ–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å–∏—Ä–∞–Ω–æ
        int middleAssigned = assignShifts(tracker, day, canWorkMiddle, ShiftType.MIDDLE, 1); // –í–∏–Ω–∞–≥–∏ –ø–æ–Ω–µ 1
        int remaining = employeesNeeded - middleAssigned;

        int firstNeeded = remaining / 2;
        int secondNeeded = remaining - firstNeeded;

        int firstAssigned = assignShifts(tracker, day, canWorkFirst, ShiftType.FIRST, firstNeeded);
        int secondAssigned = assignShifts(tracker, day, canWorkSecond, ShiftType.SECOND, secondNeeded);

        System.out.println(String.format("üìÖ %s: %d –ø—ä—Ä–≤–∏, %d –≤—Ç–æ—Ä–∏, %d –º–µ–∂–¥–∏–Ω–Ω–∏",
                day, firstAssigned, secondAssigned, middleAssigned));
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –§–∏–ª—Ç—Ä–∏—Ä–∞ —Å–ª—É–∂–∏—Ç–µ–ª–∏ –∫–æ–∏—Ç–æ –º–æ–≥–∞—Ç –¥–∞ —Ä–∞–±–æ—Ç—è—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ —Å–º—è–Ω–∞
     */
    private List<Employee> filterByAllowedShift(SimpleScheduleTracker tracker, List<Employee> employees,
                                                LocalDate day, ShiftType shiftType) {
        return employees.stream()
                .filter(emp -> canWorkSpecificShift(tracker, emp, day, shiftType))
                .collect(Collectors.toList());
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –†–∞–∑–ø—Ä–µ–¥–µ–ª—è —Å–º–µ–Ω–∏ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª–∏
     */
    private int assignShifts(SimpleScheduleTracker tracker, LocalDate day, List<Employee> candidates,
                             ShiftType shiftType, int needed) {
        int assigned = 0;
        for (Employee emp : candidates) {
            if (assigned >= needed) break;
            if (!tracker.hasShiftOnDay(emp, day)) {
                tracker.addShift(emp, day, shiftType);
                assigned++;
            }
        }
        return assigned;
    }

    /**
     * –ö–†–ò–¢–ò–ß–ù–ê –§–£–ù–ö–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ —Å–ª—É–∂–∏—Ç–µ–ª –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –≤ –¥–∞–¥–µ–Ω –¥–µ–Ω
     */
    private boolean canEmployeeWorkOnDay(SimpleScheduleTracker tracker, Employee emp, LocalDate day) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –ü–æ—á–∏–≤–µ–Ω –¥–µ–Ω
        if (tracker.isRestDay(emp, day)) {
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –í–µ—á–µ –∏–º–∞ —Å–º—è–Ω–∞ –≤ –¥–µ–Ω—è
        if (tracker.hasShiftOnDay(emp, day)) {
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ 3: –ú–∞–∫—Å–∏–º—É–º 6 –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ –¥–Ω–∏
        if (getConsecutiveWorkDays(tracker, emp, day) >= MAX_CONSECUTIVE_DAYS) {
            return false;
        }

        return true;
    }

    /**
     * –ö–†–ò–¢–ò–ß–ù–ê –§–£–ù–ö–¶–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ —Å–º—è–Ω–∞
     * –ü–û–î–û–ë–†–ï–ù–ê —Å DEBUG –ª–æ–≥–æ–≤–µ
     */
    private boolean canWorkSpecificShift(SimpleScheduleTracker tracker, Employee emp, LocalDate day, ShiftType targetShift) {
        // –ü—ä—Ä–≤–æ –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        if (!canEmployeeWorkOnDay(tracker, emp, day)) {
            return false;
        }

        // –ö–†–ò–¢–ò–ß–ù–ê –ü–†–û–í–ï–†–ö–ê: 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ —Å –ø—Ä–µ–¥—Ö–æ–¥–Ω–∏—è –¥–µ–Ω
        LocalDate previousDay = day.minusDays(1);
        ShiftType previousShift = tracker.getShiftForDay(emp, previousDay);

        if (previousShift != null) {
            boolean allowed = isShiftAllowedAfterPrevious(previousShift, targetShift);

            if (!allowed) {
                System.out.println(String.format("üö´ 12h RULE VIOLATION: %s –Ω–µ –º–æ–∂–µ %s –Ω–∞ %s —Å–ª–µ–¥ %s –Ω–∞ %s",
                        emp.getName(), targetShift.getName(), day, previousShift.getName(), previousDay));
            }

            return allowed;
        }

        return true;
    }

    /**
     * –ö–õ–Æ–ß–û–í–ê –§–£–ù–ö–¶–ò–Ø: 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ - —Å—Ç—Ä–æ–≥–æ —Å–ø–∞–∑–≤–∞–Ω–µ —Å DEBUG
     */
    private boolean isShiftAllowedAfterPrevious(ShiftType previousShift, ShiftType targetShift) {
        // –ü–†–ê–í–ò–õ–û 1: –°–ª–µ–¥ –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞ (–¥–æ 22:00) ‚Üí –°–ê–ú–û –≤—Ç–æ—Ä–∞ —Å–º—è–Ω–∞ (13:30+) —Å–ª–µ–¥–≤–∞—â–∏—è –¥–µ–Ω
        if (previousShift == ShiftType.SECOND) {
            boolean allowed = (targetShift == ShiftType.SECOND);
            System.out.println(String.format("üîç 12h CHECK: –°–ª–µ–¥ %s ‚Üí %s = %s",
                    previousShift.getName(), targetShift.getName(), allowed ? "‚úÖ –†–ê–ó–†–ï–®–ï–ù–û" : "‚ùå –ó–ê–ë–†–ê–ù–ï–ù–û"));
            return allowed;
        }

        // –ü–†–ê–í–ò–õ–û 2: –°–ª–µ–¥ –º–µ–∂–¥–∏–Ω–Ω–∞/–ø—ä—Ä–≤–∞ —Å–º—è–Ω–∞ ‚Üí –≤—Å—è–∫–∞–∫–≤–∞ —Å–º—è–Ω–∞ –µ –û–ö
        System.out.println(String.format("üîç 12h CHECK: –°–ª–µ–¥ %s ‚Üí %s = ‚úÖ –†–ê–ó–†–ï–®–ï–ù–û",
                previousShift.getName(), targetShift.getName()));
        return true;
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –ò–∑—á–∏—Å–ª—è–≤–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏
     */
    private int getConsecutiveWorkDays(SimpleScheduleTracker tracker, Employee emp, LocalDate startDay) {
        int count = 0;
        LocalDate day = startDay.minusDays(1); // –ó–∞–ø–æ—á–≤–∞–º–µ –æ—Ç –¥–µ–Ω—è –ø—Ä–µ–¥–∏

        // –ë—Ä–æ–∏–º –Ω–∞–∑–∞–¥ –∫–æ–ª–∫–æ –¥–Ω–∏ –ø–æ–¥—Ä–µ–¥ —Ä–∞–±–æ—Ç–∏
        while (day != null && tracker.hasShiftOnDay(emp, day)) {
            count++;
            day = day.minusDays(1);
            if (count >= 10) break; // –ó–∞—â–∏—Ç–∞
        }

        return count;
    }

    /**
     * –ï–¢–ê–ü 4: –û—Å–∏–≥—É—Ä—è–≤–∞ –º–∏–Ω–∏–º–∞–ª–Ω–∏—Ç–µ –¥–æ–≥–æ–≤–æ—Ä–Ω–∏ —á–∞—Å–æ–≤–µ
     */
    private void ensureMinimumHours(SimpleScheduleTracker tracker, List<LocalDate> allDays) {
        System.out.println("üíº === –ü–†–û–í–ï–†–ö–ê –ù–ê –î–û–ì–û–í–û–†–ù–ò–¢–ï –ß–ê–°–û–í–ï ===");

        for (Employee emp : tracker.getAllEmployees()) {
            double requiredHours = calculateRequiredMonthlyHours(emp);
            double currentHours = tracker.getTotalHoursForEmployee(emp);

            System.out.println(String.format("üë§ %s (–¥–æ–≥–æ–≤–æ—Ä %d—á): –∏–º–∞ %.1f—á, —Ç—Ä—è–±–≤–∞ %.1f—á",
                    emp.getName(), getContractHours(emp), currentHours, requiredHours));

            if (currentHours < requiredHours) {
                double missingHours = requiredHours - currentHours;
                addShiftsForMissingHours(tracker, emp, missingHours, allDays);
            }
        }
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ò–∑—á–∏—Å–ª—è–≤–∞ –Ω—É–∂–Ω–∏—Ç–µ –º–µ—Å–µ—á–Ω–∏ —á–∞—Å–æ–≤–µ (–æ–ø—Ä–æ—Å—Ç–µ–Ω–æ)
     */
    private double calculateRequiredMonthlyHours(Employee emp) {
        int contractHours = getContractHours(emp);

        // –û–ø—Ä–æ—Å—Ç–µ–Ω–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ: 1 –º–µ—Å–µ—Ü = 4 —Å–µ–¥–º–∏—Ü–∏
        // 4—á –¥–æ–≥–æ–≤–æ—Ä = 20—á —Å–µ–¥–º–∏—á–Ω–æ √ó 4 = 80—á –º–µ—Å–µ—á–Ω–æ
        // 6—á –¥–æ–≥–æ–≤–æ—Ä = 30—á —Å–µ–¥–º–∏—á–Ω–æ √ó 4 = 120—á –º–µ—Å–µ—á–Ω–æ
        // 8—á –¥–æ–≥–æ–≤–æ—Ä = 40—á —Å–µ–¥–º–∏—á–Ω–æ √ó 4 = 160—á –º–µ—Å–µ—á–Ω–æ
        return (contractHours * 5) * 4; // 5 –¥–Ω–∏ —Å–µ–¥–º–∏—á–Ω–æ √ó 4 —Å–µ–¥–º–∏—Ü–∏
    }

    /**
     * –ü–û–ú–û–©–ù–ê –§–£–ù–ö–¶–ò–Ø: –í—Ä—ä—â–∞ –¥–æ–≥–æ–≤–æ—Ä–Ω–∏—Ç–µ —á–∞—Å–æ–≤–µ –Ω–∞ —Å–ª—É–∂–∏—Ç–µ–ª
     */
    private int getContractHours(Employee emp) {
        return emp.getHourlyRate() != null ? emp.getHourlyRate() : 8;
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –î–æ–±–∞–≤—è —Å–º–µ–Ω–∏ –∑–∞ –ø–æ–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ –Ω–µ–¥–æ—Å—Ç–∏–≥–∞—â–∏ —á–∞—Å–æ–≤–µ
     * –ü–û–î–û–ë–†–ï–ù–ê —Å –°–¢–†–û–ì–ò –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞ 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ
     */
    private void addShiftsForMissingHours(SimpleScheduleTracker tracker, Employee emp,
                                          double missingHours, List<LocalDate> allDays) {
        System.out.println(String.format("üîß –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ %.1f —á–∞—Å–∞ –∑–∞ %s", missingHours, emp.getName()));

        int shiftsNeeded = (int) Math.ceil(missingHours / SHIFT_HOURS);
        int shiftsAdded = 0;

        // –¢—ä—Ä—Å–∏–º –¥–Ω–∏ –∫—ä–¥–µ—Ç–æ –º–æ–∂–µ –¥–∞ –¥–æ–±–∞–≤–∏–º —Å–º–µ–Ω–∏
        for (LocalDate day : allDays) {
            if (shiftsAdded >= shiftsNeeded) break;

            // –ê–∫–æ –µ –ø–æ—á–∏–≤–µ–Ω –¥–µ–Ω, –æ–ø–∏—Ç–≤–∞–º–µ —Å–µ –¥–∞ –≥–æ –Ω–∞–ø—Ä–∞–≤–∏–º —Ä–∞–±–æ—Ç–µ–Ω
            if (tracker.isRestDay(emp, day)) {
                ShiftType bestShift = findBestShiftForDayWithStrictChecks(tracker, emp, day);
                if (bestShift != null) {
                    // –î–û–ü–™–õ–ù–ò–¢–ï–õ–ù–ê –ü–†–û–í–ï–†–ö–ê: –°–ø–∞–∑–≤–∞ –ª–∏ 12-—á–∞—Å–æ–≤–æ—Ç–æ –ø—Ä–∞–≤–∏–ª–æ?
                    if (canWorkSpecificShift(tracker, emp, day, bestShift)) {
                        tracker.removeRestDay(emp, day);
                        tracker.addShift(emp, day, bestShift);
                        shiftsAdded++;

                        System.out.println(String.format("‚ûï –î–æ–±–∞–≤–µ–Ω–∞ —Å–º—è–Ω–∞: %s –Ω–∞ %s (%s)",
                                emp.getName(), day, bestShift.getName()));
                    } else {
                        System.out.println(String.format("üö´ –ù–ï –¥–æ–±–∞–≤—è–º–µ —Å–º—è–Ω–∞ –∑–∞ %s –Ω–∞ %s - –Ω–∞—Ä—É—à–∞–≤–∞ 12h –ø—Ä–∞–≤–∏–ª–æ—Ç–æ",
                                emp.getName(), day));
                    }
                }
            }
        }

        if (shiftsAdded < shiftsNeeded) {
            System.out.println(String.format("‚ö†Ô∏è %s: –î–æ–±–∞–≤–µ–Ω–∏ —Å–∞–º–æ %d –æ—Ç %d –Ω—É–∂–Ω–∏ —Å–º–µ–Ω–∏ (–∑–∞—Ä–∞–¥–∏ 12h –ø—Ä–∞–≤–∏–ª–æ—Ç–æ)",
                    emp.getName(), shiftsAdded, shiftsNeeded));
        }
    }

    /**
     * –§–£–ù–ö–¶–ò–Ø: –ù–∞–º–∏—Ä–∞ –Ω–∞–π-–ø–æ–¥—Ö–æ–¥—è—â–∞—Ç–∞ —Å–º—è–Ω–∞ –∑–∞ –¥–µ–Ω—è —Å—ä—Å –°–¢–†–û–ì–ò –ø—Ä–æ–≤–µ—Ä–∫–∏
     */
    private ShiftType findBestShiftForDayWithStrictChecks(SimpleScheduleTracker tracker, Employee emp, LocalDate day) {
        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –≤—Å–∏—á–∫–∏ —Ç–∏–ø–æ–≤–µ —Å–º–µ–Ω–∏ —Å—ä—Å —Å—Ç—Ä–æ–≥–∏ 12-—á–∞—Å–æ–≤–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏
        if (canWorkSpecificShift(tracker, emp, day, ShiftType.MIDDLE)) {
            return ShiftType.MIDDLE;
        }
        if (canWorkSpecificShift(tracker, emp, day, ShiftType.FIRST)) {
            return ShiftType.FIRST;
        }
        if (canWorkSpecificShift(tracker, emp, day, ShiftType.SECOND)) {
            return ShiftType.SECOND;
        }
        return null;
    }

    // ============================================================================
    // –ü–û–ú–û–©–ù–ò –§–£–ù–ö–¶–ò–ò –ó–ê –û–ë–†–ê–ë–û–¢–ö–ê –ù–ê –î–ê–ù–ù–ò
    // ============================================================================

    private List<LocalDate> generateAllDaysForMonth(int year, int month) {
        List<LocalDate> allDays = new ArrayList<>();
        LocalDate date = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());

        while (!date.isAfter(endOfMonth)) {
            allDays.add(date);
            date = date.plusDays(1);
        }
        return allDays;
    }

    private Map<LocalDate, List<Event>> getExistingManualShiftsByDate(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> manualEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() == null || !event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .filter(event -> event.getLeaveType() == null)
                .collect(Collectors.toList());

        return manualEvents.stream()
                .collect(Collectors.groupingBy(event -> event.getStart().toLocalDate()));
    }

    private void addExistingShiftsToTracker(SimpleScheduleTracker tracker,
                                            Map<LocalDate, List<Event>> existingShifts) {
        for (Map.Entry<LocalDate, List<Event>> entry : existingShifts.entrySet()) {
            LocalDate date = entry.getKey();
            for (Event event : entry.getValue()) {
                ShiftType shiftType = determineShiftType(event);
                tracker.addExistingShift(event.getEmployee(), date, shiftType);
            }
        }
    }

    private ShiftType determineShiftType(Event event) {
        LocalTime startTime = event.getStart().toLocalTime();

        if (startTime.equals(FIRST_SHIFT_START)) return ShiftType.FIRST;
        if (startTime.equals(SECOND_SHIFT_START)) return ShiftType.SECOND;
        if (startTime.equals(MIDDLE_SHIFT_START)) return ShiftType.MIDDLE;

        if (startTime.isBefore(LocalTime.of(10, 0))) return ShiftType.FIRST;
        if (startTime.isAfter(LocalTime.of(13, 0))) return ShiftType.SECOND;
        return ShiftType.MIDDLE;
    }

    private List<Event> createEventsFromTracker(SimpleScheduleTracker tracker) {
        List<Event> events = new ArrayList<>();

        for (Employee emp : tracker.getAllEmployees()) {
            Map<LocalDate, ShiftType> shifts = tracker.getGeneratedShiftsForEmployee(emp);

            for (Map.Entry<LocalDate, ShiftType> entry : shifts.entrySet()) {
                LocalDate date = entry.getKey();
                ShiftType shiftType = entry.getValue();

                Event event = new Event();
                event.setTitle(emp.getName().split(" ")[0]);
                event.setStart(date.atTime(shiftType.getStartTime()));
                event.setEnd(date.atTime(shiftType.getEndTime()));
                event.setActivity("Auto-generated " + shiftType.getName());
                event.setEmployee(emp);
                event.setIsAutoGenerated(true);

                events.add(event);
            }
        }

        return events;
    }

    private void deleteAutoGeneratedShiftsForMonth(int year, int month) {
        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        LocalDateTime startDateTime = startOfMonth.atStartOfDay();
        LocalDateTime endDateTime = endOfMonth.atTime(23, 59, 59);

        List<Event> autoGeneratedEvents = eventRepository.findAll().stream()
                .filter(event -> event.getIsAutoGenerated() != null && event.getIsAutoGenerated())
                .filter(event -> event.getStart() != null)
                .filter(event -> !event.getStart().isBefore(startDateTime) && !event.getStart().isAfter(endDateTime))
                .collect(Collectors.toList());

        if (!autoGeneratedEvents.isEmpty()) {
            eventRepository.deleteAll(autoGeneratedEvents);
            System.out.println(String.format("üóëÔ∏è –ò–∑—Ç—Ä–∏—Ç–∏ %d —Å—Ç–∞—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏", autoGeneratedEvents.size()));
        }
    }

    private void logFinalResults(SimpleScheduleTracker tracker, List<Event> generatedEvents) {
        System.out.println("\nüìä === –§–ò–ù–ê–õ–ù–ò –†–ï–ó–£–õ–¢–ê–¢–ò (–û–ü–†–û–°–¢–ï–ù–ò) ===");

        for (Employee emp : tracker.getAllEmployees()) {
            double totalHours = tracker.getTotalHoursForEmployee(emp);
            int workDays = tracker.getWorkDaysForEmployee(emp);
            int contractHours = getContractHours(emp);
            double requiredHours = calculateRequiredMonthlyHours(emp);

            System.out.println(String.format("üë§ %s (–¥–æ–≥–æ–≤–æ—Ä %d—á): %.1f—á –æ—Ç %.1f—á, %d —Ä–∞–±–æ—Ç–Ω–∏ –¥–Ω–∏",
                    emp.getName(), contractHours, totalHours, requiredHours, workDays));
        }

        System.out.println(String.format("\n‚úÖ –û–±—â–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–º–µ–Ω–∏: %d", generatedEvents.size()));
    }

    // ============================================================================
    // –û–ü–†–û–°–¢–ï–ù –ö–õ–ê–° –ó–ê –ü–†–û–°–õ–ï–î–Ø–í–ê–ù–ï –ù–ê –ì–†–ê–§–ò–ö–ê
    // ============================================================================

    /**
     * –ú–Ω–æ–≥–æ –ø–æ-–ø—Ä–æ—Å—Ç –∫–ª–∞—Å –∑–∞ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–∞
     * –ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞: –ú–ê–ö–°–ò–ú–£–ú 1 –°–ú–Ø–ù–ê –ù–ê –î–ï–ù –∑–∞ —Å–ª—É–∂–∏—Ç–µ–ª
     */
    public static class SimpleScheduleTracker {
        private List<Employee> employees;
        private Map<Employee, Set<LocalDate>> restDays = new HashMap<>();
        private Map<Employee, Map<LocalDate, ShiftType>> existingShifts = new HashMap<>();
        private Map<Employee, Map<LocalDate, ShiftType>> generatedShifts = new HashMap<>();

        public SimpleScheduleTracker(List<Employee> employees, List<LocalDate> allDays) {
            this.employees = employees;
            for (Employee emp : employees) {
                restDays.put(emp, new HashSet<>());
                existingShifts.put(emp, new HashMap<>());
                generatedShifts.put(emp, new HashMap<>());
            }
        }

        // –ú–µ—Ç–æ–¥–∏ –∑–∞ –ø–æ—á–∏–≤–Ω–∏ –¥–Ω–∏
        public void setRestDay(Employee emp, LocalDate day) {
            restDays.get(emp).add(day);
        }

        public void removeRestDay(Employee emp, LocalDate day) {
            restDays.get(emp).remove(day);
        }

        public boolean isRestDay(Employee emp, LocalDate day) {
            return restDays.get(emp).contains(day);
        }

        // –ú–µ—Ç–æ–¥–∏ –∑–∞ —Å–º–µ–Ω–∏ - –ì–ê–†–ê–ù–¢–ò–†–ê –ú–ê–ö–°–ò–ú–£–ú 1 –°–ú–Ø–ù–ê –ù–ê –î–ï–ù
        public void addExistingShift(Employee emp, LocalDate day, ShiftType shiftType) {
            if (hasShiftOnDay(emp, day)) {
                System.out.println(String.format("‚ö†Ô∏è WARNING: %s –≤–µ—á–µ –∏–º–∞ —Å–º—è–Ω–∞ –Ω–∞ %s!", emp.getName(), day));
                return;
            }
            existingShifts.get(emp).put(day, shiftType);
        }

        public void addShift(Employee emp, LocalDate day, ShiftType shiftType) {
            if (hasShiftOnDay(emp, day)) {
                System.out.println(String.format("‚ö†Ô∏è WARNING: %s –≤–µ—á–µ –∏–º–∞ —Å–º—è–Ω–∞ –Ω–∞ %s!", emp.getName(), day));
                return;
            }
            generatedShifts.get(emp).put(day, shiftType);
        }

        public boolean hasShiftOnDay(Employee emp, LocalDate day) {
            return existingShifts.get(emp).containsKey(day) || generatedShifts.get(emp).containsKey(day);
        }

        public ShiftType getShiftForDay(Employee emp, LocalDate day) {
            if (existingShifts.get(emp).containsKey(day)) {
                return existingShifts.get(emp).get(day);
            }
            return generatedShifts.get(emp).get(day);
        }

        // –ú–µ—Ç–æ–¥–∏ –∑–∞ –∞–Ω–∞–ª–∏–∑
        public double getTotalHoursForEmployee(Employee emp) {
            int totalShifts = existingShifts.get(emp).size() + generatedShifts.get(emp).size();
            return totalShifts * SHIFT_HOURS;
        }

        public int getWorkDaysForEmployee(Employee emp) {
            Set<LocalDate> allWorkDays = new HashSet<>(existingShifts.get(emp).keySet());
            allWorkDays.addAll(generatedShifts.get(emp).keySet());
            return allWorkDays.size();
        }

        // Getters
        public List<Employee> getAllEmployees() {
            return employees;
        }

        public Map<LocalDate, ShiftType> getGeneratedShiftsForEmployee(Employee emp) {
            return generatedShifts.get(emp);
        }
    }
}